---
phase: 10-area-tool-overhaul
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - components/exams/graph-editor/region-detection/intersection-solver.ts
  - components/exams/graph-editor/region-detection/intersection-solver.test.ts
  - components/exams/graph-editor/region-detection/boundary-tracer.ts
  - components/exams/graph-editor/region-detection/boundary-tracer.test.ts
  - components/exams/graph-editor/region-detection/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Intersection solver finds where two functions cross within a domain"
    - "Intersection solver finds where a line crosses a function"
    - "Intersection solver finds where two lines cross"
    - "Boundary tracer generates polygon from curves between intersection points"
    - "Boundary tracer can use lines as domain boundaries (not just intersection points)"
    - "Tests pass for common cases (parabola+line, two parabolas, sin+linear, line segments)"
  artifacts:
    - path: "components/exams/graph-editor/region-detection/intersection-solver.ts"
      provides: "findFunctionIntersections, findLineFunctionIntersection, findLineLineIntersection, bisection algorithm"
      exports: ["findFunctionIntersections", "findLineFunctionIntersection", "findLineLineIntersection"]
    - path: "components/exams/graph-editor/region-detection/boundary-tracer.ts"
      provides: "generatePolygonBetweenCurves, generatePolygonBoundedByElements, sampleFunctionInDomain"
      exports: ["generatePolygonBetweenCurves", "generatePolygonBoundedByElements", "sampleFunctionInDomain"]
    - path: "components/exams/graph-editor/region-detection/index.ts"
      provides: "Barrel export"
      exports: ["findFunctionIntersections", "findLineFunctionIntersection", "findLineLineIntersection", "generatePolygonBetweenCurves", "generatePolygonBoundedByElements"]
  key_links:
    - from: "intersection-solver.ts"
      to: "graph-utils.ts"
      via: "compileExpression import"
      pattern: "import.*compileExpression.*from.*graph-utils"
    - from: "boundary-tracer.ts"
      to: "intersection-solver.ts"
      via: "Uses intersection results for domain bounds"
      pattern: "findFunctionIntersections|findLineFunctionIntersection"
---

<objective>
Build TDD-driven region detection utilities for finding curve/line intersections and tracing polygon boundaries.

Purpose: Enable accurate area detection when teacher drops area tool between curves, lines, and axes. The intersection solver finds where elements cross (determining the area domain), and the boundary tracer generates the polygon outline. ALL visible lines (GraphLine) must be able to act as boundaries - not just functions.

Output: Tested region-detection utilities ready for integration into EditableArea.
</objective>

<execution_context>
@C:\Users\hugol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hugol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-area-tool-overhaul/10-RESEARCH.md

@components/exams/graph-utils.ts
@components/exams/graph-editor/canvas/shapes/EditableArea.tsx
@types/exams.ts
</context>

<feature>
  <name>Intersection Solver - Function-Function</name>
  <files>
    components/exams/graph-editor/region-detection/intersection-solver.ts,
    components/exams/graph-editor/region-detection/intersection-solver.test.ts
  </files>
  <behavior>
    Given two function expressions and a domain [xMin, xMax]:
    - Find all x values where f(x) = g(x)
    - Use bisection method for numerical root finding
    - Handle discontinuities gracefully (skip NaN/Infinity)

    Cases:
    - findFunctionIntersections("x^2", "x", -5, 5) -> [0, 1] (x^2 = x at x=0 and x=1)
    - findFunctionIntersections("x^2", "2*x - 1", -5, 5) -> [1] (parabola touches line at x=1)
    - findFunctionIntersections("sin(x)", "0.5", 0, 6.28) -> [~0.524, ~2.618] (sin crosses 0.5 twice in [0, 2pi])
    - findFunctionIntersections("x^2", "x + 5", -5, 5) -> [] (no intersection in domain)
  </behavior>
  <implementation>
    1. Create region-detection folder under graph-editor
    2. Import compileExpression from @/components/exams/graph-utils
    3. Implement bisection(f, a, b, tolerance, maxIterations) helper
    4. Implement findFunctionIntersections(expr1, expr2, xMin, xMax, tolerance):
       - Compile both expressions
       - Define h(x) = f(x) - g(x)
       - Sample h at 100+ points to find sign changes
       - For each sign change, apply bisection to find root
       - Return sorted array of x values
    5. Handle edge cases: invalid expressions, no intersections, discontinuities
  </implementation>
</feature>

<feature>
  <name>Intersection Solver - Line-Function</name>
  <files>
    components/exams/graph-editor/region-detection/intersection-solver.ts,
    components/exams/graph-editor/region-detection/intersection-solver.test.ts
  </files>
  <behavior>
    Given a GraphLine (with start, end points and kind) and a function expression:
    - Find all x values where the line crosses the function curve
    - For 'segment' kind: only return intersections within segment bounds
    - For 'line' kind: extend infinitely, find all intersections in domain
    - For 'ray' kind: extend from start through end direction

    Cases:
    - findLineFunctionIntersection({start:{x:0,y:0}, end:{x:2,y:2}, kind:'line'}, "x^2", -5, 5) -> [0, 1]
      (y=x line intersects y=x^2 at x=0 and x=1)
    - findLineFunctionIntersection({start:{x:0,y:1}, end:{x:2,y:1}, kind:'segment'}, "x^2", -5, 5) -> [1, -1]
      (horizontal line y=1 intersects parabola at x=1 and x=-1)
    - findLineFunctionIntersection({start:{x:5,y:0}, end:{x:5,y:5}, kind:'line'}, "x^2", -5, 5) -> [{x:5, y:25}]
      (vertical line x=5 intersects at point where x=5)
  </behavior>
  <implementation>
    1. Compute line equation: y = mx + b (or handle vertical line x=constant)
    2. For non-vertical line: find f(x) = mx + b, same bisection approach
    3. For vertical line x=c: just evaluate f(c) if c is in domain
    4. Filter results based on line kind (segment bounds, ray direction)
    5. Return sorted array of intersection points {x, y}
  </implementation>
</feature>

<feature>
  <name>Intersection Solver - Line-Line</name>
  <files>
    components/exams/graph-editor/region-detection/intersection-solver.ts,
    components/exams/graph-editor/region-detection/intersection-solver.test.ts
  </files>
  <behavior>
    Given two GraphLine objects:
    - Find the point where two lines intersect (if any)
    - Handle parallel lines (no intersection)
    - Respect line kinds (segment, line, ray) - intersection must be within bounds

    Cases:
    - findLineLineIntersection({start:{x:0,y:0}, end:{x:2,y:2}}, {start:{x:0,y:2}, end:{x:2,y:0}}) -> {x:1, y:1}
    - findLineLineIntersection({start:{x:0,y:0}, end:{x:1,y:1}}, {start:{x:0,y:1}, end:{x:1,y:2}}) -> null (parallel)
    - findLineLineIntersection(segment1, segment2) -> null if intersection point is outside both segments
  </behavior>
  <implementation>
    1. Use standard 2D line intersection formula:
       - Line 1: P1 + t*(P2-P1)
       - Line 2: P3 + u*(P4-P3)
       - Solve for t and u
    2. Check for parallel (denominator = 0)
    3. Filter based on kind:
       - segment: t and u must be in [0,1]
       - line: no filtering
       - ray: t >= 0 (or u >= 0 for respective lines)
    4. Return intersection point or null
  </implementation>
</feature>

<feature>
  <name>Boundary Tracer - Between Functions</name>
  <files>
    components/exams/graph-editor/region-detection/boundary-tracer.ts,
    components/exams/graph-editor/region-detection/boundary-tracer.test.ts
  </files>
  <behavior>
    Given two GraphFunction objects and a domain [xMin, xMax]:
    - Sample both functions at high resolution
    - Generate closed polygon: upper curve forward, lower curve backward
    - Sort functions by which is "on top" at midpoint

    Cases:
    - generatePolygonBetweenCurves(f1={expr:"x^2"}, f2={expr:"x"}, 0, 1, 60) ->
      Array of ~121 points forming closed polygon (60 upper + 60 lower + close)
    - Functions with offsets (offsetX, offsetY, scaleY) are handled correctly
    - Empty result if either function is invalid or domain has no valid samples
  </behavior>
  <implementation>
    1. Create sampleFunctionInDomain(func: GraphFunction, minX, maxX, samples) helper
       - Handle offsetX, offsetY, scaleY transformations
       - Skip points where y is NaN/Infinity
    2. Implement generatePolygonBetweenCurves(func1, func2, xMin, xMax, numSamples):
       - Sample both functions
       - Determine which is "upper" at domain midpoint
       - Create polygon: upperSamples forward + lowerSamples reversed
       - Return array of {x, y} points
    3. Export from index.ts barrel file
  </implementation>
</feature>

<feature>
  <name>Boundary Tracer - Mixed Elements</name>
  <files>
    components/exams/graph-editor/region-detection/boundary-tracer.ts,
    components/exams/graph-editor/region-detection/boundary-tracer.test.ts
  </files>
  <behavior>
    Given a mix of GraphFunction and GraphLine elements that bound a region:
    - Generate closed polygon following all boundary elements
    - Support common patterns: function bounded by vertical line, function bounded by axis, etc.

    Cases:
    - generatePolygonBoundedByElements({upperFunc, lowerLine, leftX, rightX}) ->
      Polygon from upper function down to lower line
    - Area under f(x) bounded by x-axis and x=2 vertical line ->
      Polygon from f(x) samples, along x-axis, up vertical line
    - Two functions bounded by vertical lines on left and right ->
      Polygon respecting line boundaries as domain limits
  </behavior>
  <implementation>
    1. Create BoundaryElement type union: GraphFunction | GraphLine | {type:'axis', axis:'x'|'y', value:number}
    2. Implement generatePolygonBoundedByElements(boundaries: BoundaryElement[], dropPoint):
       - Identify which elements form the closed boundary
       - For functions: sample between domain bounds
       - For lines/segments: add line points directly
       - For axes: treat as lines at x=0 or y=0
       - Connect elements in order (clockwise or counterclockwise)
    3. Handle edge cases:
       - Vertical lines define domain bounds (xMin/xMax)
       - Horizontal lines define function boundaries
       - Non-vertical/horizontal lines: compute intersections
  </implementation>
</feature>

<verification>
```bash
# Run TDD tests
npx tsx --test components/exams/graph-editor/region-detection/*.test.ts

# Verify TypeScript compilation
npx tsc --noEmit
```
</verification>

<success_criteria>
1. All intersection-solver tests pass:
   - Function-function intersections (4+ test cases)
   - Line-function intersections (4+ test cases)
   - Line-line intersections (4+ test cases)
2. All boundary-tracer tests pass:
   - generatePolygonBetweenCurves (3+ test cases)
   - generatePolygonBoundedByElements (3+ test cases)
3. No TypeScript errors
4. Functions handle edge cases (invalid expressions, no intersections, discontinuities, parallel lines)
</success_criteria>

<output>
After completion, create `.planning/phases/10-area-tool-overhaul/10-01-SUMMARY.md`
</output>

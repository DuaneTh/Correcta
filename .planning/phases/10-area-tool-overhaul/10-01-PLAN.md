---
phase: 10-area-tool-overhaul
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - components/exams/graph-editor/region-detection/intersection-solver.ts
  - components/exams/graph-editor/region-detection/intersection-solver.test.ts
  - components/exams/graph-editor/region-detection/boundary-tracer.ts
  - components/exams/graph-editor/region-detection/boundary-tracer.test.ts
  - components/exams/graph-editor/region-detection/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Intersection solver finds where two functions cross within a domain"
    - "Boundary tracer generates polygon from curves between intersection points"
    - "Tests pass for common cases (parabola+line, two parabolas, sin+linear)"
  artifacts:
    - path: "components/exams/graph-editor/region-detection/intersection-solver.ts"
      provides: "findFunctionIntersections, bisection algorithm"
      exports: ["findFunctionIntersections"]
    - path: "components/exams/graph-editor/region-detection/boundary-tracer.ts"
      provides: "generatePolygonBetweenCurves, sampleFunctionInDomain"
      exports: ["generatePolygonBetweenCurves", "sampleFunctionInDomain"]
    - path: "components/exams/graph-editor/region-detection/index.ts"
      provides: "Barrel export"
      exports: ["findFunctionIntersections", "generatePolygonBetweenCurves"]
  key_links:
    - from: "intersection-solver.ts"
      to: "graph-utils.ts"
      via: "compileExpression import"
      pattern: "import.*compileExpression.*from.*graph-utils"
    - from: "boundary-tracer.ts"
      to: "intersection-solver.ts"
      via: "Uses intersection results for domain bounds"
      pattern: "findFunctionIntersections"
---

<objective>
Build TDD-driven region detection utilities for finding curve intersections and tracing polygon boundaries.

Purpose: Enable accurate area detection when teacher drops area tool between two functions. The intersection solver finds where curves cross (determining the area domain), and the boundary tracer generates the polygon outline.

Output: Tested region-detection utilities ready for integration into EditableArea.
</objective>

<execution_context>
@C:\Users\hugol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hugol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-area-tool-overhaul/10-RESEARCH.md

@components/exams/graph-utils.ts
@components/exams/graph-editor/canvas/shapes/EditableArea.tsx
@types/exams.ts
</context>

<feature>
  <name>Intersection Solver</name>
  <files>
    components/exams/graph-editor/region-detection/intersection-solver.ts,
    components/exams/graph-editor/region-detection/intersection-solver.test.ts
  </files>
  <behavior>
    Given two function expressions and a domain [xMin, xMax]:
    - Find all x values where f(x) = g(x)
    - Use bisection method for numerical root finding
    - Handle discontinuities gracefully (skip NaN/Infinity)

    Cases:
    - findFunctionIntersections("x^2", "x", -5, 5) -> [0, 1] (x^2 = x at x=0 and x=1)
    - findFunctionIntersections("x^2", "2*x - 1", -5, 5) -> [1] (parabola touches line at x=1)
    - findFunctionIntersections("sin(x)", "0.5", 0, 6.28) -> [~0.524, ~2.618] (sin crosses 0.5 twice in [0, 2pi])
    - findFunctionIntersections("x^2", "x + 5", -5, 5) -> [] (no intersection in domain)
  </behavior>
  <implementation>
    1. Create region-detection folder under graph-editor
    2. Import compileExpression from @/components/exams/graph-utils
    3. Implement bisection(f, a, b, tolerance, maxIterations) helper
    4. Implement findFunctionIntersections(expr1, expr2, xMin, xMax, tolerance):
       - Compile both expressions
       - Define h(x) = f(x) - g(x)
       - Sample h at 100+ points to find sign changes
       - For each sign change, apply bisection to find root
       - Return sorted array of x values
    5. Handle edge cases: invalid expressions, no intersections, discontinuities
  </implementation>
</feature>

<feature>
  <name>Boundary Tracer</name>
  <files>
    components/exams/graph-editor/region-detection/boundary-tracer.ts,
    components/exams/graph-editor/region-detection/boundary-tracer.test.ts
  </files>
  <behavior>
    Given two GraphFunction objects and a domain [xMin, xMax]:
    - Sample both functions at high resolution
    - Generate closed polygon: upper curve forward, lower curve backward
    - Sort functions by which is "on top" at midpoint

    Cases:
    - generatePolygonBetweenCurves(f1={expr:"x^2"}, f2={expr:"x"}, 0, 1, 60) ->
      Array of ~121 points forming closed polygon (60 upper + 60 lower + close)
    - Functions with offsets (offsetX, offsetY, scaleY) are handled correctly
    - Empty result if either function is invalid or domain has no valid samples
  </behavior>
  <implementation>
    1. Create sampleFunctionInDomain(func: GraphFunction, minX, maxX, samples) helper
       - Handle offsetX, offsetY, scaleY transformations
       - Skip points where y is NaN/Infinity
    2. Implement generatePolygonBetweenCurves(func1, func2, xMin, xMax, numSamples):
       - Sample both functions
       - Determine which is "upper" at domain midpoint
       - Create polygon: upperSamples forward + lowerSamples reversed
       - Return array of {x, y} points
    3. Export from index.ts barrel file
  </implementation>
</feature>

<verification>
```bash
# Run TDD tests
npx tsx --test components/exams/graph-editor/region-detection/*.test.ts

# Verify TypeScript compilation
npx tsc --noEmit
```
</verification>

<success_criteria>
1. All intersection-solver tests pass (4+ test cases)
2. All boundary-tracer tests pass (3+ test cases)
3. No TypeScript errors
4. Functions handle edge cases (invalid expressions, no intersections, discontinuities)
</success_criteria>

<output>
After completion, create `.planning/phases/10-area-tool-overhaul/10-01-SUMMARY.md`
</output>

---
phase: 10-area-tool-overhaul
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - types/exams.ts
  - components/exams/graph-editor/region-detection/intersection-solver.ts
  - components/exams/graph-editor/region-detection/intersection-solver.test.ts
  - components/exams/graph-editor/region-detection/boundary-tracer.ts
  - components/exams/graph-editor/region-detection/boundary-tracer.test.ts
  - components/exams/graph-editor/region-detection/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Intersection solver finds where two functions cross within a domain"
    - "Intersection solver finds where a line crosses a function"
    - "Intersection solver finds where two lines cross"
    - "Boundary tracer generates polygon from curves between intersection points"
    - "Boundary tracer can use lines as domain boundaries (not just intersection points)"
    - "Boundary tracer treats visible axes (x=0 or y=0) as implicit line boundaries"
    - "Tests pass for common cases (parabola+line, two parabolas, sin+linear, line segments)"
    - "GraphArea type supports ignoredBoundaries and boundaryIds for extend feature"
  artifacts:
    - path: "types/exams.ts"
      provides: "GraphArea type with boundaryIds, ignoredBoundaries, and bounded-region mode"
      contains: "ignoredBoundaries|boundaryIds|bounded-region"
    - path: "components/exams/graph-editor/region-detection/intersection-solver.ts"
      provides: "findFunctionIntersections, findLineFunctionIntersection, findLineLineIntersection, bisection algorithm"
      exports: ["findFunctionIntersections", "findLineFunctionIntersection", "findLineLineIntersection"]
    - path: "components/exams/graph-editor/region-detection/boundary-tracer.ts"
      provides: "generatePolygonBetweenCurves, generatePolygonBoundedByElements, sampleFunctionInDomain"
      exports: ["generatePolygonBetweenCurves", "generatePolygonBoundedByElements", "sampleFunctionInDomain"]
    - path: "components/exams/graph-editor/region-detection/index.ts"
      provides: "Barrel export"
      exports: ["findFunctionIntersections", "findLineFunctionIntersection", "findLineLineIntersection", "generatePolygonBetweenCurves", "generatePolygonBoundedByElements"]
  key_links:
    - from: "intersection-solver.ts"
      to: "graph-utils.ts"
      via: "compileExpression import"
      pattern: "import.*compileExpression.*from.*graph-utils"
    - from: "boundary-tracer.ts"
      to: "intersection-solver.ts"
      via: "Uses intersection results for domain bounds"
      pattern: "findFunctionIntersections|findLineFunctionIntersection"
---

<objective>
Build TDD-driven region detection utilities for finding curve/line intersections and tracing polygon boundaries, plus update GraphArea type for extend feature.

Purpose: Enable accurate area detection when teacher drops area tool between curves, lines, and axes. The intersection solver finds where elements cross (determining the area domain), and the boundary tracer generates the polygon outline. ALL visible lines (GraphLine) AND visible axes (x=0, y=0 when within canvas bounds) must be able to act as boundaries - not just functions.

Output: Tested region-detection utilities ready for integration into EditableArea. Updated GraphArea type ready for Plan 10-02 and 10-03.
</objective>

<execution_context>
@C:\Users\hugol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hugol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-area-tool-overhaul/10-RESEARCH.md

@components/exams/graph-utils.ts
@components/exams/graph-editor/canvas/shapes/EditableArea.tsx
@types/exams.ts
</context>

<task type="auto">
  <name>Task 0: Update GraphArea type for extend feature</name>
  <files>types/exams.ts</files>
  <action>
Update the GraphArea type to support new boundary modes and the extend feature.

**Changes to GraphArea type** (around line 136):

```typescript
export type GraphArea = {
    id: string
    /** Display label for the area (e.g., "A" or "\mathcal{A}") */
    label?: string
    /** If true, label is rendered as LaTeX math */
    labelIsMath?: boolean
    labelSegments?: ContentSegment[]
    /** Whether to show the label (default: true) */
    showLabel?: boolean
    /** Position of the label/control point in graph coordinates */
    labelPos?: { x: number; y: number }
    /**
     * How the area polygon is determined:
     * - 'polygon': Direct point list
     * - 'under-function': Area between function and y=0
     * - 'between-functions': Area between two functions
     * - 'between-line-and-function': Area between a line and function
     * - 'bounded-region': Area bounded by mix of functions, lines, axes
     */
    mode: 'polygon' | 'under-function' | 'between-functions' | 'between-line-and-function' | 'bounded-region'
    /** Direct polygon points (used when mode='polygon' or as cached result) */
    points?: GraphAnchor[]
    /** Primary function ID (for under-function, between-functions, between-line-and-function) */
    functionId?: string
    /** Secondary function ID (for between-functions mode) */
    functionId2?: string
    /** Line ID (for between-line-and-function mode) */
    lineId?: string
    /** All element IDs that bound this area (for bounded-region mode) */
    boundaryIds?: string[]
    /** X-axis domain for area calculation */
    domain?: { min?: number; max?: number }
    /** Fill style (color, opacity) */
    fill?: GraphFillStyle
    /**
     * Element IDs to ignore as boundaries (for "extend" feature).
     * When set, area extends across these boundaries to fill adjacent regions.
     */
    ignoredBoundaries?: string[]
}
```

The key additions:
- `'bounded-region'` mode for mixed element boundaries
- `boundaryIds` to track all bounding elements
- `ignoredBoundaries` to mark which lines should be crossed (extend feature)
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`. No breaking changes to existing code.
  </verify>
  <done>
GraphArea type supports all area modes including bounded-region, boundaryIds, and ignoredBoundaries for extend feature.
  </done>
</task>

<feature>
  <name>Feature 1: Intersection Solver - Function-Function</name>
  <files>
    components/exams/graph-editor/region-detection/intersection-solver.ts,
    components/exams/graph-editor/region-detection/intersection-solver.test.ts
  </files>
  <behavior>
    Given two function expressions and a domain [xMin, xMax]:
    - Find all x values where f(x) = g(x)
    - Use bisection method for numerical root finding
    - Handle discontinuities gracefully (skip NaN/Infinity)

    Cases:
    - findFunctionIntersections("x^2", "x", -5, 5) -> [0, 1] (x^2 = x at x=0 and x=1)
    - findFunctionIntersections("x^2", "2*x - 1", -5, 5) -> [1] (parabola touches line at x=1)
    - findFunctionIntersections("sin(x)", "0.5", 0, 6.28) -> [~0.524, ~2.618] (sin crosses 0.5 twice in [0, 2pi])
    - findFunctionIntersections("x^2", "x + 5", -5, 5) -> [] (no intersection in domain)
  </behavior>
  <implementation>
    1. Create region-detection folder under graph-editor
    2. Import compileExpression from @/components/exams/graph-utils
    3. Implement bisection(f, a, b, tolerance, maxIterations) helper
    4. Implement findFunctionIntersections(expr1, expr2, xMin, xMax, tolerance):
       - Compile both expressions
       - Define h(x) = f(x) - g(x)
       - Sample h at 100+ points to find sign changes
       - For each sign change, apply bisection to find root
       - Return sorted array of x values
    5. Handle edge cases: invalid expressions, no intersections, discontinuities
  </implementation>
</feature>

<feature>
  <name>Feature 2: Intersection Solver - Line-Function</name>
  <files>
    components/exams/graph-editor/region-detection/intersection-solver.ts,
    components/exams/graph-editor/region-detection/intersection-solver.test.ts
  </files>
  <behavior>
    Given a GraphLine (with start, end points and kind) and a function expression:
    - Find all x values where the line crosses the function curve
    - For 'segment' kind: only return intersections within segment bounds
    - For 'line' kind: extend infinitely, find all intersections in domain
    - For 'ray' kind: extend from start through end direction

    Cases:
    - findLineFunctionIntersection({start:{x:0,y:0}, end:{x:2,y:2}, kind:'line'}, "x^2", -5, 5) -> [0, 1]
      (y=x line intersects y=x^2 at x=0 and x=1)
    - findLineFunctionIntersection({start:{x:0,y:1}, end:{x:2,y:1}, kind:'segment'}, "x^2", -5, 5) -> [1, -1]
      (horizontal line y=1 intersects parabola at x=1 and x=-1)
    - findLineFunctionIntersection({start:{x:5,y:0}, end:{x:5,y:5}, kind:'line'}, "x^2", -5, 5) -> [{x:5, y:25}]
      (vertical line x=5 intersects at point where x=5)
  </behavior>
  <implementation>
    1. Compute line equation: y = mx + b (or handle vertical line x=constant)
    2. For non-vertical line: find f(x) = mx + b, same bisection approach
    3. For vertical line x=c: just evaluate f(c) if c is in domain
    4. Filter results based on line kind (segment bounds, ray direction)
    5. Return sorted array of intersection points {x, y}
  </implementation>
</feature>

<feature>
  <name>Feature 3: Intersection Solver - Line-Line</name>
  <files>
    components/exams/graph-editor/region-detection/intersection-solver.ts,
    components/exams/graph-editor/region-detection/intersection-solver.test.ts
  </files>
  <behavior>
    Given two GraphLine objects:
    - Find the point where two lines intersect (if any)
    - Handle parallel lines (no intersection)
    - Respect line kinds (segment, line, ray) - intersection must be within bounds

    Cases:
    - findLineLineIntersection({start:{x:0,y:0}, end:{x:2,y:2}}, {start:{x:0,y:2}, end:{x:2,y:0}}) -> {x:1, y:1}
    - findLineLineIntersection({start:{x:0,y:0}, end:{x:1,y:1}}, {start:{x:0,y:1}, end:{x:1,y:2}}) -> null (parallel)
    - findLineLineIntersection(segment1, segment2) -> null if intersection point is outside both segments
  </behavior>
  <implementation>
    1. Use standard 2D line intersection formula:
       - Line 1: P1 + t*(P2-P1)
       - Line 2: P3 + u*(P4-P3)
       - Solve for t and u
    2. Check for parallel (denominator = 0)
    3. Filter based on kind:
       - segment: t and u must be in [0,1]
       - line: no filtering
       - ray: t >= 0 (or u >= 0 for respective lines)
    4. Return intersection point or null
  </implementation>
</feature>

<feature>
  <name>Feature 4: Boundary Tracer - Between Functions</name>
  <files>
    components/exams/graph-editor/region-detection/boundary-tracer.ts,
    components/exams/graph-editor/region-detection/boundary-tracer.test.ts
  </files>
  <behavior>
    Given two GraphFunction objects and a domain [xMin, xMax]:
    - Sample both functions at high resolution
    - Generate closed polygon: upper curve forward, lower curve backward
    - Sort functions by which is "on top" at midpoint

    Cases:
    - generatePolygonBetweenCurves(f1={expr:"x^2"}, f2={expr:"x"}, 0, 1, 60) ->
      Array of ~121 points forming closed polygon (60 upper + 60 lower + close)
    - Functions with offsets (offsetX, offsetY, scaleY) are handled correctly
    - Empty result if either function is invalid or domain has no valid samples
  </behavior>
  <implementation>
    1. Create sampleFunctionInDomain(func: GraphFunction, minX, maxX, samples) helper
       - Handle offsetX, offsetY, scaleY transformations
       - Skip points where y is NaN/Infinity
    2. Implement generatePolygonBetweenCurves(func1, func2, xMin, xMax, numSamples):
       - Sample both functions
       - Determine which is "upper" at domain midpoint
       - Create polygon: upperSamples forward + lowerSamples reversed
       - Return array of {x, y} points
    3. Export from index.ts barrel file
  </implementation>
</feature>

<feature>
  <name>Feature 5: Boundary Tracer - Mixed Elements with Axis Support</name>
  <files>
    components/exams/graph-editor/region-detection/boundary-tracer.ts,
    components/exams/graph-editor/region-detection/boundary-tracer.test.ts
  </files>
  <behavior>
    Given a mix of GraphFunction, GraphLine elements, and axis information that bound a region:
    - Generate closed polygon following all boundary elements
    - Support common patterns: function bounded by vertical line, function bounded by axis, etc.
    - Treat x-axis (y=0) and y-axis (x=0) as implicit line boundaries when visible within canvas bounds

    Cases:
    - generatePolygonBoundedByElements(boundaries, dropPoint, axes) where axes.yMin < 0 < axes.yMax:
      x-axis (y=0) is treated as an available boundary
    - Area under f(x) bounded by x-axis and x=2 vertical line ->
      Polygon from f(x) samples, along x-axis, up vertical line
    - Two functions bounded by vertical lines on left and right ->
      Polygon respecting line boundaries as domain limits
    - Area bounded by function and y-axis (x=0) when y-axis is visible
  </behavior>
  <implementation>
    1. Create BoundaryElement type union:
       ```typescript
       type BoundaryElement =
         | { type: 'function'; element: GraphFunction }
         | { type: 'line'; element: GraphLine }
         | { type: 'axis'; axis: 'x' | 'y'; value: number }  // x-axis at y=0, y-axis at x=0
       ```

    2. Implement generatePolygonBoundedByElements(boundaries: BoundaryElement[], dropPoint: {x, y}, axes: GraphAxes):
       - **Axis detection:** Check if x-axis (y=0) is visible (axes.yMin <= 0 <= axes.yMax)
         and y-axis (x=0) is visible (axes.xMin <= 0 <= axes.xMax). If visible, treat as implicit boundaries.
       - Identify which elements form the closed boundary around dropPoint
       - For functions: sample between domain bounds
       - For lines/segments: add line points directly
       - For axes: treat as horizontal line at y=0 (x-axis) or vertical line at x=0 (y-axis)
       - Connect elements in order (clockwise or counterclockwise)

    3. Handle edge cases:
       - Vertical lines define domain bounds (xMin/xMax)
       - Horizontal lines define function boundaries
       - x-axis (y=0) acts as horizontal line when visible
       - y-axis (x=0) acts as vertical line when visible
       - Non-vertical/horizontal lines: compute intersections
  </implementation>
</feature>

<verification>
```bash
# Run TDD tests (Node.js test runner with tsx - confirmed correct for this project)
npx tsx --test components/exams/graph-editor/region-detection/*.test.ts

# Verify TypeScript compilation
npx tsc --noEmit
```

Note: This project uses the Node.js built-in test runner with tsx, not vitest. The command `npx tsx --test` is correct.
</verification>

<success_criteria>
1. GraphArea type updated with boundaryIds, ignoredBoundaries, and bounded-region mode
2. All intersection-solver tests pass:
   - Function-function intersections (4+ test cases)
   - Line-function intersections (4+ test cases)
   - Line-line intersections (4+ test cases)
3. All boundary-tracer tests pass:
   - generatePolygonBetweenCurves (3+ test cases)
   - generatePolygonBoundedByElements with axes parameter (3+ test cases)
4. Axis handling works: x-axis and y-axis treated as implicit boundaries when visible
5. No TypeScript errors
6. Functions handle edge cases (invalid expressions, no intersections, discontinuities, parallel lines)
</success_criteria>

<output>
After completion, create `.planning/phases/10-area-tool-overhaul/10-01-SUMMARY.md`
</output>

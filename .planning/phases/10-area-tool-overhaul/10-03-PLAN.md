---
phase: 10-area-tool-overhaul
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - components/exams/graph-editor/canvas/shapes/EditableArea.tsx
  - components/exams/graph-editor/SimpleGraphEditor.tsx
  - types/exams.ts
autonomous: true

must_haves:
  truths:
    - "Dragging area control point between two functions auto-detects the bounded region"
    - "Area fills the zone from left intersection to right intersection"
    - "Area between x^2 and x fills correctly between x=0 and x=1"
    - "Area between sin(x) and linear function fills correctly"
    - "Control point position determines which region to fill when multiple regions exist"
  artifacts:
    - path: "components/exams/graph-editor/canvas/shapes/EditableArea.tsx"
      provides: "Multi-function region detection on drag end"
      contains: "findFunctionIntersections"
    - path: "types/exams.ts"
      provides: "GraphArea type with between-functions mode support"
      contains: "between-functions"
  key_links:
    - from: "EditableArea.tsx"
      to: "region-detection/index.ts"
      via: "Import intersection solver and boundary tracer"
      pattern: "import.*from.*region-detection"
    - from: "EditableArea.tsx"
      to: "handleDragEnd"
      via: "Multi-function detection logic in drag end handler"
      pattern: "handleDragEnd.*findFunctionIntersections"
---

<objective>
Enhance EditableArea to detect closed regions bounded by multiple functions using the TDD-built region detection utilities.

Purpose: Enables AREA-01, AREA-02, AREA-04 requirements - automatic detection of closed regions bounded by multiple curves with correct polygon generation.

Output: Working drag-and-drop area tool that auto-fills regions between functions.
</objective>

<execution_context>
@C:\Users\hugol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hugol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-area-tool-overhaul/10-01-SUMMARY.md

@components/exams/graph-editor/canvas/shapes/EditableArea.tsx
@components/exams/graph-editor/SimpleGraphEditor.tsx
@components/exams/graph-editor/region-detection/index.ts
@types/exams.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance EditableArea with multi-function detection</name>
  <files>components/exams/graph-editor/canvas/shapes/EditableArea.tsx</files>
  <action>
Refactor EditableArea.tsx to use the region-detection utilities for detecting areas between two functions.

**Changes:**

1. **Import region-detection utilities:**
   ```typescript
   import { findFunctionIntersections, generatePolygonBetweenCurves } from '../region-detection'
   ```

2. **Enhance handleDragEnd function** (around line 272):

   Replace the current detection logic with improved multi-function support:

   ```typescript
   const handleDragEnd = useCallback((e: any) => {
     const node = e.target
     const newPos = pixelToGraph({ x: node.x(), y: node.y() }, axes, width, height)

     // Find the two nearest functions to the drop point
     const sortedFuncs = functions
       .map(fn => {
         const nearest = findNearestFunction({ x: newPos.x, y: newPos.y }, [fn])
         return nearest ? { func: fn, distance: nearest.distance, y: nearest.y } : null
       })
       .filter(Boolean)
       .sort((a, b) => a!.distance - b!.distance)

     // PRIORITY 1: Between two functions
     if (sortedFuncs.length >= 2) {
       const func1 = sortedFuncs[0]!.func
       const func2 = sortedFuncs[1]!.func

       // Find intersections between the two functions
       const intersections = findFunctionIntersections(
         func1.expression,
         func2.expression,
         axes.xMin,
         axes.xMax
       )

       if (intersections.length >= 2) {
         // Find the domain that contains the drop point
         let domainMin = axes.xMin
         let domainMax = axes.xMax

         // Check each pair of consecutive intersections
         for (let i = 0; i < intersections.length - 1; i++) {
           if (newPos.x >= intersections[i] && newPos.x <= intersections[i + 1]) {
             domainMin = intersections[i]
             domainMax = intersections[i + 1]
             break
           }
         }

         // Generate polygon between the two functions in this domain
         const polygon = generatePolygonBetweenCurves(func1, func2, domainMin, domainMax, 60)

         if (polygon.length >= 3) {
           const newPoints: GraphAnchor[] = polygon.map(pt => ({
             type: 'coord' as const,
             x: pt.x,
             y: pt.y
           }))

           onUpdate({
             ...area,
             mode: 'between-functions',
             functionId: func1.id,
             functionId2: func2.id,
             domain: { min: domainMin, max: domainMax },
             points: newPoints,
             labelPos: newPos
           })
           setDragPos(null)
           return
         }
       }
     }

     // PRIORITY 2: Existing logic for single function + line
     // (Keep current nearestFunc + nearestLine logic as fallback)
     ...
   }, [area, functions, lines, axes, width, height, onUpdate])
   ```

3. **Update findNearestFunction** to work with a single function array (for reuse in sorting).

4. **Handle edge cases:**
   - If drop point is outside all intersection pairs, use the nearest pair
   - If only 0 or 1 intersection found, fall back to under-function mode
   - Ensure discontinuous functions don't crash (filter NaN points)

**Key insight from research:** Use the control point position to disambiguate which region to fill when curves intersect multiple times.
  </action>
  <verify>
TypeScript compiles. Basic functional test: Add parabola (x^2) and linear (x), drop area between them.
  </verify>
  <done>
EditableArea detects when control point is between two functions and auto-fills that region.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SimpleGraphEditor drop handler for multi-function areas</name>
  <files>components/exams/graph-editor/SimpleGraphEditor.tsx</files>
  <action>
Enhance the area drop detection in SimpleGraphEditor.handleCanvasDrop to use the new region detection.

**Changes to handleCanvasDrop** (around line 142-272):

1. **Import region-detection:**
   ```typescript
   import { findFunctionIntersections, generatePolygonBetweenCurves } from './region-detection'
   ```

2. **Enhance area drop logic** (in the section handling newElements.areas):

   Replace the current simple threshold-based detection with proper intersection-based detection:

   ```typescript
   if (newElements.areas) {
     const funcs = value.functions || []
     const lns = value.lines || []

     // Sort functions by distance to drop point
     const sortedFuncs = funcs
       .map(fn => {
         const nearest = findNearestFunction(dropCoord, [fn])
         return nearest ? { func: fn, ...nearest } : null
       })
       .filter(Boolean)
       .sort((a, b) => a!.distance - b!.distance)

     const threshold = 3.0 // Graph units

     newElements.areas = newElements.areas.map(a => {
       // TWO FUNCTIONS: Detect intersection-bounded region
       if (sortedFuncs.length >= 2 &&
           sortedFuncs[0]!.distance < threshold &&
           sortedFuncs[1]!.distance < threshold) {

         const func1 = sortedFuncs[0]!.func
         const func2 = sortedFuncs[1]!.func

         const intersections = findFunctionIntersections(
           func1.expression,
           func2.expression,
           value.axes.xMin,
           value.axes.xMax
         )

         if (intersections.length >= 2) {
           // Find domain containing drop point
           let domainMin = intersections[0]
           let domainMax = intersections[intersections.length - 1]

           for (let i = 0; i < intersections.length - 1; i++) {
             if (dropCoord.x >= intersections[i] && dropCoord.x <= intersections[i + 1]) {
               domainMin = intersections[i]
               domainMax = intersections[i + 1]
               break
             }
           }

           const polygon = generatePolygonBetweenCurves(func1, func2, domainMin, domainMax, 60)

           if (polygon.length >= 3) {
             return {
               ...a,
               mode: 'between-functions' as const,
               functionId: func1.id,
               functionId2: func2.id,
               domain: { min: domainMin, max: domainMax },
               points: polygon.map(pt => ({ type: 'coord' as const, x: pt.x, y: pt.y })),
               labelPos: dropCoord
             }
           }
         }
       }

       // ONE FUNCTION + LINE: existing logic
       // ... (keep current between-line-and-function detection)

       // ONE FUNCTION only: existing under-function logic
       // ... (keep current under-function detection)

       // FALLBACK: placeholder area at drop position
       return {
         ...a,
         mode: 'polygon' as const,
         labelPos: dropCoord,
         points: []
       }
     })
   }
   ```

3. **Keep existing line+function detection** as second priority.

4. **Clean up unused imports** if any.
  </action>
  <verify>
```bash
npx tsc --noEmit
npm run dev
```
Test: Add parabola and linear function, drop area between them. Area should auto-fill bounded region.
  </verify>
  <done>
Dropping area between two functions auto-detects intersections and fills bounded region.
  </done>
</task>

<task type="auto">
  <name>Task 3: Ensure GraphArea type supports all modes properly</name>
  <files>types/exams.ts</files>
  <action>
Verify and update GraphArea type to properly support all area modes.

**Current GraphArea type** (around line 136):
```typescript
export type GraphArea = {
    id: string
    label?: string
    labelIsMath?: boolean
    labelSegments?: ContentSegment[]
    showLabel?: boolean
    labelPos?: { x: number; y: number }
    mode: 'polygon' | 'under-function' | 'between-functions' | 'between-line-and-function'
    points?: GraphAnchor[]
    functionId?: string
    functionId2?: string
    lineId?: string
    domain?: { min?: number; max?: number }
    fill?: GraphFillStyle
}
```

**Verify this covers all modes:**
- `polygon`: Uses `points` array directly
- `under-function`: Uses `functionId` + `domain`
- `between-functions`: Uses `functionId` + `functionId2` + `domain`
- `between-line-and-function`: Uses `functionId` + `lineId` + `domain`

The type is already correct. No changes needed unless:
- Add JSDoc comments explaining each mode
- Ensure all optional fields are properly marked

**Add JSDoc comments:**
```typescript
export type GraphArea = {
    id: string
    /** Display label for the area (e.g., "A" or "\mathcal{A}") */
    label?: string
    /** If true, label is rendered as LaTeX math */
    labelIsMath?: boolean
    labelSegments?: ContentSegment[]
    /** Whether to show the label (default: true) */
    showLabel?: boolean
    /** Position of the label/control point in graph coordinates */
    labelPos?: { x: number; y: number }
    /**
     * How the area polygon is determined:
     * - 'polygon': Direct point list
     * - 'under-function': Area between function and y=0
     * - 'between-functions': Area between two functions
     * - 'between-line-and-function': Area between a line and function
     */
    mode: 'polygon' | 'under-function' | 'between-functions' | 'between-line-and-function'
    /** Direct polygon points (used when mode='polygon' or as cached result) */
    points?: GraphAnchor[]
    /** Primary function ID (for under-function, between-functions, between-line-and-function) */
    functionId?: string
    /** Secondary function ID (for between-functions mode) */
    functionId2?: string
    /** Line ID (for between-line-and-function mode) */
    lineId?: string
    /** X-axis domain for area calculation */
    domain?: { min?: number; max?: number }
    /** Fill style (color, opacity) */
    fill?: GraphFillStyle
}
```
  </action>
  <verify>
TypeScript compiles without errors. JSDoc comments appear in IDE hover.
  </verify>
  <done>
GraphArea type is documented and supports all area modes correctly.
  </done>
</task>

</tasks>

<verification>
Full integration test:
1. Start dev server: `npm run dev`
2. Open exam builder, add a graph question
3. Add a parabola (x^2) from shape palette
4. Add a linear function (x) from shape palette
5. Add an area from shape palette
6. Drag the area control point between the two curves (around x=0.5)
7. **Expected:** Area fills the region bounded by x^2 and x, from x=0 to x=1
8. Drag control point to a different position
9. **Expected:** Area updates to the new bounded region
10. Select area, change color in properties panel
11. **Expected:** Fill color changes
</verification>

<success_criteria>
1. Area dropped between two functions auto-detects intersection domain
2. Polygon fills correctly between the curves
3. Dragging control point updates the region
4. Works for various function pairs (parabola+linear, sin+linear, two parabolas)
5. Falls back gracefully when functions don't intersect
6. No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-area-tool-overhaul/10-03-SUMMARY.md`
</output>

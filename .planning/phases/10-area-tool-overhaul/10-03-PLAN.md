---
phase: 10-area-tool-overhaul
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - components/exams/graph-editor/canvas/shapes/EditableArea.tsx
  - components/exams/graph-editor/SimpleGraphEditor.tsx
  - components/exams/graph-editor/AreaPropertiesPanel.tsx
autonomous: true

must_haves:
  truths:
    - "Dragging area control point between two functions auto-detects the bounded region"
    - "Area fills the zone from left intersection to right intersection"
    - "ALL visible lines (GraphLine) act as area boundaries"
    - "Visible axes (x=0, y=0) act as implicit boundaries when within canvas range"
    - "Grid lines (background carreaux) do NOT act as boundaries"
    - "Teacher can extend area across a line boundary to span multiple regions"
    - "Area between x^2 and x fills correctly between x=0 and x=1"
    - "Area bounded by function + vertical line fills correctly"
    - "Control point position determines which region to fill when multiple regions exist"
  artifacts:
    - path: "components/exams/graph-editor/canvas/shapes/EditableArea.tsx"
      provides: "Multi-element region detection on drag end, extend mode support, axis handling"
      contains: "findFunctionIntersections|findLineFunctionIntersection|generatePolygonBoundedByElements"
    - path: "components/exams/graph-editor/AreaPropertiesPanel.tsx"
      provides: "Extend mode toggle for ignoring specific boundaries"
      contains: "ignoredBoundaries|extendMode"
  key_links:
    - from: "EditableArea.tsx"
      to: "region-detection/index.ts"
      via: "Import intersection solver and boundary tracer"
      pattern: "import.*from.*region-detection"
    - from: "EditableArea.tsx"
      to: "handleDragEnd"
      via: "Multi-element detection logic in drag end handler"
      pattern: "handleDragEnd.*(findFunctionIntersections|findLineFunctionIntersection)"
    - from: "AreaPropertiesPanel.tsx"
      to: "ignoredBoundaries"
      via: "Toggle to extend area across boundaries"
      pattern: "ignoredBoundaries|onToggleBoundary"
---

<objective>
Enhance EditableArea to detect closed regions bounded by functions, lines, AND visible axes, with the ability to extend areas across boundaries.

Purpose: Enables AREA-01, AREA-02, AREA-04 requirements - automatic detection of closed regions bounded by ANY visible line (functions, segments, axes) with correct polygon generation. Grid lines are excluded. Teachers can extend areas across specific boundaries when needed.

Output: Working drag-and-drop area tool that auto-fills regions between functions/lines/axes, with extend mode.
</objective>

<execution_context>
@C:\Users\hugol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hugol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-area-tool-overhaul/10-01-SUMMARY.md

@components/exams/graph-editor/canvas/shapes/EditableArea.tsx
@components/exams/graph-editor/SimpleGraphEditor.tsx
@components/exams/graph-editor/AreaPropertiesPanel.tsx
@components/exams/graph-editor/region-detection/index.ts
@types/exams.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance EditableArea with multi-element detection and axis support</name>
  <files>components/exams/graph-editor/canvas/shapes/EditableArea.tsx</files>
  <action>
Refactor EditableArea.tsx to detect areas bounded by functions, lines, AND visible axes.

**Changes:**

1. **Import region-detection utilities:**
   ```typescript
   import {
     findFunctionIntersections,
     findLineFunctionIntersection,
     findLineLineIntersection,
     generatePolygonBetweenCurves,
     generatePolygonBoundedByElements,
     type BoundaryElement
   } from '../region-detection'
   ```

2. **Add helper to find nearest line:**
   ```typescript
   function findNearestLine(point: {x: number, y: number}, lines: GraphLine[]): {line: GraphLine, distance: number} | null {
     // For each line, compute distance from point to line segment/line/ray
     // Return closest line and its distance
   }
   ```

3. **Add axis detection helper:**
   ```typescript
   function getVisibleAxes(axes: GraphAxes): BoundaryElement[] {
     const result: BoundaryElement[] = []

     // X-axis (y=0) is visible if yMin <= 0 <= yMax
     if (axes.yMin <= 0 && axes.yMax >= 0) {
       result.push({ type: 'axis', axis: 'x', value: 0 })
     }

     // Y-axis (x=0) is visible if xMin <= 0 <= xMax
     if (axes.xMin <= 0 && axes.xMax >= 0) {
       result.push({ type: 'axis', axis: 'y', value: 0 })
     }

     return result
   }
   ```

4. **Enhance handleDragEnd function** (around line 272):

   Replace the current detection logic with comprehensive multi-element support:

   ```typescript
   const handleDragEnd = useCallback((e: any) => {
     const node = e.target
     const newPos = pixelToGraph({ x: node.x(), y: node.y() }, axes, width, height)

     // Collect ALL potential boundaries (functions + lines + visible axes, but NOT grid)
     const nearbyFuncs = functions
       .map(fn => {
         const nearest = findNearestFunction({ x: newPos.x, y: newPos.y }, [fn])
         return nearest ? { type: 'function' as const, element: fn, distance: nearest.distance, y: nearest.y } : null
       })
       .filter(Boolean)

     const nearbyLines = lines
       .map(ln => {
         const nearest = findNearestLine({ x: newPos.x, y: newPos.y }, [ln])
         return nearest ? { type: 'line' as const, element: ln, distance: nearest.distance } : null
       })
       .filter(Boolean)

     // Add visible axes as implicit boundaries
     const visibleAxes = getVisibleAxes(axes)
     const nearbyAxes = visibleAxes
       .map(ax => {
         // Distance to x-axis (y=0) is |newPos.y|
         // Distance to y-axis (x=0) is |newPos.x|
         const distance = ax.axis === 'x' ? Math.abs(newPos.y) : Math.abs(newPos.x)
         return { ...ax, distance }
       })

     // Merge and sort by distance
     const allBoundaries = [...nearbyFuncs, ...nearbyLines, ...nearbyAxes]
       .sort((a, b) => a!.distance - b!.distance)

     // Filter out ignoredBoundaries (for extend mode)
     const activeBoundaries = allBoundaries.filter(b => {
       // For axes, use synthetic IDs like 'x-axis' or 'y-axis'
       const id = b.type === 'axis' ? `${b.axis}-axis` : b.element.id
       return !area.ignoredBoundaries?.includes(id)
     })

     const threshold = 3.0 // Graph units

     // PRIORITY 1: Two functions (most common case)
     const closeFuncs = activeBoundaries
       .filter(b => b!.type === 'function' && b!.distance < threshold)
       .slice(0, 2)

     if (closeFuncs.length >= 2) {
       const func1 = closeFuncs[0]!.element as GraphFunction
       const func2 = closeFuncs[1]!.element as GraphFunction

       // Find intersections between the two functions
       const intersections = findFunctionIntersections(
         func1.expression,
         func2.expression,
         axes.xMin,
         axes.xMax
       )

       // Also check for line boundaries that might limit domain
       const nearbyVerticalLines = activeBoundaries
         .filter(b => b!.type === 'line')
         .map(b => b!.element as GraphLine)
         .filter(ln => isVerticalLine(ln))

       // Check for y-axis as boundary
       const yAxisBoundary = activeBoundaries.find(b => b.type === 'axis' && b.axis === 'y')

       let domainMin = axes.xMin
       let domainMax = axes.xMax

       // Vertical lines can limit the domain
       for (const vLine of nearbyVerticalLines) {
         const lineX = vLine.start.x // Assuming anchor resolves to x
         if (lineX < newPos.x && lineX > domainMin) domainMin = lineX
         if (lineX > newPos.x && lineX < domainMax) domainMax = lineX
       }

       // Y-axis (x=0) can also limit domain
       if (yAxisBoundary && yAxisBoundary.distance < threshold) {
         if (0 < newPos.x && 0 > domainMin) domainMin = 0
         if (0 > newPos.x && 0 < domainMax) domainMax = 0
       }

       if (intersections.length >= 2) {
         // Find the domain containing drop point
         for (let i = 0; i < intersections.length - 1; i++) {
           if (newPos.x >= intersections[i] && newPos.x <= intersections[i + 1]) {
             domainMin = Math.max(domainMin, intersections[i])
             domainMax = Math.min(domainMax, intersections[i + 1])
             break
           }
         }
       }

       // Generate polygon
       const polygon = generatePolygonBetweenCurves(func1, func2, domainMin, domainMax, 60)

       if (polygon.length >= 3) {
         const newPoints: GraphAnchor[] = polygon.map(pt => ({
           type: 'coord' as const,
           x: pt.x,
           y: pt.y
         }))

         onUpdate({
           ...area,
           mode: 'between-functions',
           functionId: func1.id,
           functionId2: func2.id,
           boundaryIds: [func1.id, func2.id, ...nearbyVerticalLines.map(l => l.id)],
           domain: { min: domainMin, max: domainMax },
           points: newPoints,
           labelPos: newPos
         })
         setDragPos(null)
         return
       }
     }

     // PRIORITY 2: Function + Line(s) or Function + Axis
     const closeFunc = activeBoundaries.find(b => b!.type === 'function' && b!.distance < threshold)
     const closeLine = activeBoundaries.find(b => b!.type === 'line' && b!.distance < threshold)
     const closeAxis = activeBoundaries.find(b => b.type === 'axis' && b.distance < threshold)

     if (closeFunc && (closeLine || closeAxis)) {
       const func = closeFunc.element as GraphFunction

       // Build boundary elements array for generatePolygonBoundedByElements
       const boundaries: BoundaryElement[] = [{ type: 'function', element: func }]

       if (closeLine) {
         boundaries.push({ type: 'line', element: closeLine.element as GraphLine })
       }
       if (closeAxis) {
         boundaries.push(closeAxis as BoundaryElement)
       }

       // Generate polygon bounded by elements (with axes parameter)
       const polygon = generatePolygonBoundedByElements(boundaries, newPos, axes)

       if (polygon.length >= 3) {
         const boundaryIds = [func.id]
         if (closeLine) boundaryIds.push((closeLine.element as GraphLine).id)
         if (closeAxis) boundaryIds.push(`${closeAxis.axis}-axis`)

         onUpdate({
           ...area,
           mode: closeAxis && !closeLine ? 'under-function' : 'between-line-and-function',
           functionId: func.id,
           lineId: closeLine ? (closeLine.element as GraphLine).id : undefined,
           boundaryIds,
           points: polygon.map(pt => ({ type: 'coord' as const, x: pt.x, y: pt.y })),
           labelPos: newPos
         })
         setDragPos(null)
         return
       }
     }

     // PRIORITY 3: Under single function (existing logic - falls back to x-axis if visible)
     // ... keep current fallback logic but use x-axis as implicit boundary when visible

   }, [area, functions, lines, axes, width, height, onUpdate])
   ```

5. **Add helper for vertical line detection:**
   ```typescript
   function isVerticalLine(line: GraphLine): boolean {
     const startX = resolveAnchorX(line.start)
     const endX = resolveAnchorX(line.end)
     return Math.abs(startX - endX) < 0.001
   }
   ```
  </action>
  <verify>
TypeScript compiles. Basic functional test: Add parabola (x^2), linear (x), and a vertical line segment. Drop area between them.
  </verify>
  <done>
EditableArea detects regions bounded by any combination of functions, lines, and visible axes. Vertical lines and y-axis act as domain boundaries. X-axis acts as lower/upper boundary.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add extend mode to AreaPropertiesPanel</name>
  <files>components/exams/graph-editor/AreaPropertiesPanel.tsx</files>
  <action>
Add an "Extend" section to AreaPropertiesPanel that lets teachers ignore specific boundaries.

**Changes:**

1. **Enhance Props interface:**
   ```typescript
   interface AreaPropertiesPanelProps {
     area: GraphArea
     onUpdate: (updated: GraphArea) => void
     locale?: string
     /** All elements that could be boundaries (for extend mode) */
     potentialBoundaries?: Array<{ id: string; label: string; type: 'function' | 'line' | 'axis' }>
   }
   ```

2. **Add Extend section** (after Opacity section):

   ```typescript
   {/* EXTEND MODE SECTION */}
   {potentialBoundaries && potentialBoundaries.length > 0 && (
     <div className="space-y-2">
       <label className="text-xs font-medium text-gray-600 uppercase">
         {locale === 'fr' ? 'Etendre' : 'Extend'}
       </label>
       <p className="text-xs text-gray-500">
         {locale === 'fr'
           ? 'Cochez les lignes a traverser pour etendre l\'aire'
           : 'Check lines to cross and extend the area'}
       </p>
       <div className="space-y-1">
         {potentialBoundaries
           .filter(b => area.boundaryIds?.includes(b.id) || isNearbyBoundary(b.id))
           .map(boundary => (
             <label key={boundary.id} className="flex items-center gap-2 text-sm">
               <input
                 type="checkbox"
                 checked={area.ignoredBoundaries?.includes(boundary.id) || false}
                 onChange={(e) => {
                   const newIgnored = e.target.checked
                     ? [...(area.ignoredBoundaries || []), boundary.id]
                     : (area.ignoredBoundaries || []).filter(id => id !== boundary.id)
                   onUpdate({ ...area, ignoredBoundaries: newIgnored })
                 }}
                 className="rounded border-gray-300"
               />
               <span className="truncate">
                 {boundary.label || `${boundary.type} ${boundary.id.slice(0, 6)}`}
               </span>
             </label>
           ))}
       </div>
     </div>
   )}
   ```

3. **Include axis boundaries in potentialBoundaries:**
   - When passing potentialBoundaries from SimpleGraphEditor, include:
     - `{ id: 'x-axis', label: 'X-axis (y=0)', type: 'axis' }` if x-axis is visible
     - `{ id: 'y-axis', label: 'Y-axis (x=0)', type: 'axis' }` if y-axis is visible

4. **Style notes:**
   - Checkboxes styled with Tailwind
   - Show only boundaries that are currently active (part of boundaryIds) or nearby
   - Truncate long labels
   - Clear explanation text for the feature

**User flow:**
1. Teacher drops area between function and vertical line
2. Area fills up to the line
3. Teacher checks the line in Extend section
4. Area recalculates, now crossing that line to fill adjacent region
  </action>
  <verify>
File exists. TypeScript compiles. Extend section renders when potentialBoundaries is provided.
  </verify>
  <done>
AreaPropertiesPanel has extend mode allowing teacher to ignore specific boundaries including axes.
  </done>
</task>

</tasks>

<verification>
Full integration test:
1. Start dev server: `npm run dev`
2. Open exam builder, add a graph question
3. Add a parabola (x^2) from shape palette
4. Add a linear function (x) from shape palette
5. Add an area from shape palette
6. Drag the area control point between the two curves (around x=0.5)
7. **Expected:** Area fills the region bounded by x^2 and x, from x=0 to x=1

8. Add a vertical line segment at x=0.5
9. Drag area control point to the left of the line (around x=0.3)
10. **Expected:** Area fills only the left portion (x=0 to x=0.5)

11. Select the area, open properties panel
12. In Extend section, check the vertical line
13. **Expected:** Area recalculates to fill entire region (x=0 to x=1), crossing the line

14. Test with horizontal line segment
15. **Expected:** Area bounded by function and horizontal line fills correctly

16. Test with axes as boundaries:
    - Canvas showing origin (x-axis and y-axis visible)
    - Add f(x) = x^2
    - Drop area below curve near origin
    - **Expected:** Area fills between x^2 and x-axis
</verification>

<success_criteria>
1. Area dropped between two functions auto-detects intersection domain
2. Polygon fills correctly between the curves
3. Vertical lines (GraphLine) act as domain boundaries
4. Horizontal lines act as value boundaries
5. X-axis (y=0) acts as boundary when visible within canvas
6. Y-axis (x=0) acts as boundary when visible within canvas
7. Grid lines (background) are NOT treated as boundaries
8. Extend mode allows crossing specific boundaries (including axes)
9. Dragging control point updates the region
10. Works for various combinations (func+func, func+line, func+axis, func+multiple lines)
11. No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-area-tool-overhaul/10-03-SUMMARY.md`
</output>

---
phase: 10-area-tool-overhaul
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - components/exams/graph-editor/canvas/shapes/EditableArea.tsx
  - components/exams/graph-editor/SimpleGraphEditor.tsx
  - components/exams/graph-editor/AreaPropertiesPanel.tsx
  - types/exams.ts
autonomous: true

must_haves:
  truths:
    - "Dragging area control point between two functions auto-detects the bounded region"
    - "Area fills the zone from left intersection to right intersection"
    - "ALL visible lines (GraphLine) act as area boundaries"
    - "Grid lines (background carreaux) do NOT act as boundaries"
    - "Teacher can extend area across a line boundary to span multiple regions"
    - "Area between x^2 and x fills correctly between x=0 and x=1"
    - "Area bounded by function + vertical line fills correctly"
    - "Control point position determines which region to fill when multiple regions exist"
  artifacts:
    - path: "components/exams/graph-editor/canvas/shapes/EditableArea.tsx"
      provides: "Multi-element region detection on drag end, extend mode support"
      contains: "findFunctionIntersections|findLineFunctionIntersection"
    - path: "components/exams/graph-editor/AreaPropertiesPanel.tsx"
      provides: "Extend mode toggle for ignoring specific boundaries"
      contains: "ignoredBoundaries|extendMode"
    - path: "types/exams.ts"
      provides: "GraphArea type with between-functions mode support and ignoredBoundaries"
      contains: "between-functions|ignoredBoundaries"
  key_links:
    - from: "EditableArea.tsx"
      to: "region-detection/index.ts"
      via: "Import intersection solver and boundary tracer"
      pattern: "import.*from.*region-detection"
    - from: "EditableArea.tsx"
      to: "handleDragEnd"
      via: "Multi-element detection logic in drag end handler"
      pattern: "handleDragEnd.*(findFunctionIntersections|findLineFunctionIntersection)"
    - from: "AreaPropertiesPanel.tsx"
      to: "ignoredBoundaries"
      via: "Toggle to extend area across boundaries"
      pattern: "ignoredBoundaries|onToggleBoundary"
---

<objective>
Enhance EditableArea to detect closed regions bounded by functions AND lines, with the ability to extend areas across boundaries.

Purpose: Enables AREA-01, AREA-02, AREA-04 requirements - automatic detection of closed regions bounded by ANY visible line (functions, segments, axes) with correct polygon generation. Grid lines are excluded. Teachers can extend areas across specific boundaries when needed.

Output: Working drag-and-drop area tool that auto-fills regions between functions/lines, with extend mode.
</objective>

<execution_context>
@C:\Users\hugol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hugol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-area-tool-overhaul/10-01-SUMMARY.md

@components/exams/graph-editor/canvas/shapes/EditableArea.tsx
@components/exams/graph-editor/SimpleGraphEditor.tsx
@components/exams/graph-editor/AreaPropertiesPanel.tsx
@components/exams/graph-editor/region-detection/index.ts
@types/exams.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update GraphArea type to support all boundary modes and extend feature</name>
  <files>types/exams.ts</files>
  <action>
Update the GraphArea type to support:
1. New mode for mixed boundaries
2. ignoredBoundaries field for extend feature
3. boundaryIds to track which elements bound the area

**Changes to GraphArea type** (around line 136):

```typescript
export type GraphArea = {
    id: string
    /** Display label for the area (e.g., "A" or "\mathcal{A}") */
    label?: string
    /** If true, label is rendered as LaTeX math */
    labelIsMath?: boolean
    labelSegments?: ContentSegment[]
    /** Whether to show the label (default: true) */
    showLabel?: boolean
    /** Position of the label/control point in graph coordinates */
    labelPos?: { x: number; y: number }
    /**
     * How the area polygon is determined:
     * - 'polygon': Direct point list
     * - 'under-function': Area between function and y=0
     * - 'between-functions': Area between two functions
     * - 'between-line-and-function': Area between a line and function
     * - 'bounded-region': Area bounded by mix of functions, lines, axes
     */
    mode: 'polygon' | 'under-function' | 'between-functions' | 'between-line-and-function' | 'bounded-region'
    /** Direct polygon points (used when mode='polygon' or as cached result) */
    points?: GraphAnchor[]
    /** Primary function ID (for under-function, between-functions, between-line-and-function) */
    functionId?: string
    /** Secondary function ID (for between-functions mode) */
    functionId2?: string
    /** Line ID (for between-line-and-function mode) */
    lineId?: string
    /** All element IDs that bound this area (for bounded-region mode) */
    boundaryIds?: string[]
    /** X-axis domain for area calculation */
    domain?: { min?: number; max?: number }
    /** Fill style (color, opacity) */
    fill?: GraphFillStyle
    /**
     * Element IDs to ignore as boundaries (for "extend" feature).
     * When set, area extends across these boundaries to fill adjacent regions.
     */
    ignoredBoundaries?: string[]
}
```

The key additions:
- `'bounded-region'` mode for mixed element boundaries
- `boundaryIds` to track all bounding elements
- `ignoredBoundaries` to mark which lines should be crossed (extend feature)
  </action>
  <verify>
TypeScript compiles without errors. No breaking changes to existing code.
  </verify>
  <done>
GraphArea type supports all area modes including bounded-region and ignoredBoundaries for extend feature.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance EditableArea with multi-element detection</name>
  <files>components/exams/graph-editor/canvas/shapes/EditableArea.tsx</files>
  <action>
Refactor EditableArea.tsx to detect areas bounded by functions AND lines.

**Changes:**

1. **Import region-detection utilities:**
   ```typescript
   import {
     findFunctionIntersections,
     findLineFunctionIntersection,
     findLineLineIntersection,
     generatePolygonBetweenCurves,
     generatePolygonBoundedByElements
   } from '../region-detection'
   ```

2. **Add helper to find nearest line:**
   ```typescript
   function findNearestLine(point: {x: number, y: number}, lines: GraphLine[]): {line: GraphLine, distance: number} | null {
     // For each line, compute distance from point to line segment/line/ray
     // Return closest line and its distance
   }
   ```

3. **Enhance handleDragEnd function** (around line 272):

   Replace the current detection logic with comprehensive multi-element support:

   ```typescript
   const handleDragEnd = useCallback((e: any) => {
     const node = e.target
     const newPos = pixelToGraph({ x: node.x(), y: node.y() }, axes, width, height)

     // Collect ALL potential boundaries (functions + lines, but NOT grid)
     const nearbyFuncs = functions
       .map(fn => {
         const nearest = findNearestFunction({ x: newPos.x, y: newPos.y }, [fn])
         return nearest ? { type: 'function' as const, element: fn, distance: nearest.distance, y: nearest.y } : null
       })
       .filter(Boolean)

     const nearbyLines = lines
       .map(ln => {
         const nearest = findNearestLine({ x: newPos.x, y: newPos.y }, [ln])
         return nearest ? { type: 'line' as const, element: ln, distance: nearest.distance } : null
       })
       .filter(Boolean)

     // Merge and sort by distance
     const allBoundaries = [...nearbyFuncs, ...nearbyLines]
       .sort((a, b) => a!.distance - b!.distance)

     // Filter out ignoredBoundaries (for extend mode)
     const activeBoundaries = allBoundaries.filter(b =>
       !area.ignoredBoundaries?.includes(b!.element.id)
     )

     const threshold = 3.0 // Graph units

     // PRIORITY 1: Two functions (most common case)
     const closeFuncs = activeBoundaries
       .filter(b => b!.type === 'function' && b!.distance < threshold)
       .slice(0, 2)

     if (closeFuncs.length >= 2) {
       const func1 = closeFuncs[0]!.element as GraphFunction
       const func2 = closeFuncs[1]!.element as GraphFunction

       // Find intersections between the two functions
       const intersections = findFunctionIntersections(
         func1.expression,
         func2.expression,
         axes.xMin,
         axes.xMax
       )

       // Also check for line boundaries that might limit domain
       const nearbyVerticalLines = activeBoundaries
         .filter(b => b!.type === 'line')
         .map(b => b!.element as GraphLine)
         .filter(ln => isVerticalLine(ln))

       let domainMin = axes.xMin
       let domainMax = axes.xMax

       // Vertical lines can limit the domain
       for (const vLine of nearbyVerticalLines) {
         const lineX = vLine.start.x // Assuming anchor resolves to x
         if (lineX < newPos.x && lineX > domainMin) domainMin = lineX
         if (lineX > newPos.x && lineX < domainMax) domainMax = lineX
       }

       if (intersections.length >= 2) {
         // Find the domain containing drop point
         for (let i = 0; i < intersections.length - 1; i++) {
           if (newPos.x >= intersections[i] && newPos.x <= intersections[i + 1]) {
             domainMin = Math.max(domainMin, intersections[i])
             domainMax = Math.min(domainMax, intersections[i + 1])
             break
           }
         }
       }

       // Generate polygon
       const polygon = generatePolygonBetweenCurves(func1, func2, domainMin, domainMax, 60)

       if (polygon.length >= 3) {
         const newPoints: GraphAnchor[] = polygon.map(pt => ({
           type: 'coord' as const,
           x: pt.x,
           y: pt.y
         }))

         onUpdate({
           ...area,
           mode: 'between-functions',
           functionId: func1.id,
           functionId2: func2.id,
           boundaryIds: [func1.id, func2.id, ...nearbyVerticalLines.map(l => l.id)],
           domain: { min: domainMin, max: domainMax },
           points: newPoints,
           labelPos: newPos
         })
         setDragPos(null)
         return
       }
     }

     // PRIORITY 2: Function + Line(s)
     const closeFunc = activeBoundaries.find(b => b!.type === 'function' && b!.distance < threshold)
     const closeLine = activeBoundaries.find(b => b!.type === 'line' && b!.distance < threshold)

     if (closeFunc && closeLine) {
       const func = closeFunc.element as GraphFunction
       const line = closeLine.element as GraphLine

       // Find where line intersects function
       const lineIntersections = findLineFunctionIntersection(line, func.expression, axes)

       // Generate polygon bounded by function and line
       const polygon = generatePolygonBoundedByElements(
         [{ type: 'function', element: func }, { type: 'line', element: line }],
         newPos,
         axes
       )

       if (polygon.length >= 3) {
         onUpdate({
           ...area,
           mode: 'between-line-and-function',
           functionId: func.id,
           lineId: line.id,
           boundaryIds: [func.id, line.id],
           points: polygon.map(pt => ({ type: 'coord' as const, x: pt.x, y: pt.y })),
           labelPos: newPos
         })
         setDragPos(null)
         return
       }
     }

     // PRIORITY 3: Under single function (existing logic)
     // ... keep current fallback logic

   }, [area, functions, lines, axes, width, height, onUpdate])
   ```

4. **Add helper for vertical line detection:**
   ```typescript
   function isVerticalLine(line: GraphLine): boolean {
     const startX = resolveAnchorX(line.start)
     const endX = resolveAnchorX(line.end)
     return Math.abs(startX - endX) < 0.001
   }
   ```
  </action>
  <verify>
TypeScript compiles. Basic functional test: Add parabola (x^2), linear (x), and a vertical line segment. Drop area between them.
  </verify>
  <done>
EditableArea detects regions bounded by any combination of functions and lines. Vertical lines act as domain boundaries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add extend mode to AreaPropertiesPanel</name>
  <files>components/exams/graph-editor/AreaPropertiesPanel.tsx</files>
  <action>
Add an "Extend" section to AreaPropertiesPanel that lets teachers ignore specific boundaries.

**Changes:**

1. **Enhance Props interface:**
   ```typescript
   interface AreaPropertiesPanelProps {
     area: GraphArea
     onUpdate: (updated: GraphArea) => void
     locale?: string
     /** All elements that could be boundaries (for extend mode) */
     potentialBoundaries?: Array<{ id: string; label: string; type: 'function' | 'line' }>
   }
   ```

2. **Add Extend section** (after Opacity section):

   ```typescript
   {/* EXTEND MODE SECTION */}
   {potentialBoundaries && potentialBoundaries.length > 0 && (
     <div className="space-y-2">
       <label className="text-xs font-medium text-gray-600 uppercase">
         {locale === 'fr' ? 'Etendre' : 'Extend'}
       </label>
       <p className="text-xs text-gray-500">
         {locale === 'fr'
           ? 'Cochez les lignes a traverser pour etendre l\'aire'
           : 'Check lines to cross and extend the area'}
       </p>
       <div className="space-y-1">
         {potentialBoundaries
           .filter(b => area.boundaryIds?.includes(b.id) || isNearbyBoundary(b.id))
           .map(boundary => (
             <label key={boundary.id} className="flex items-center gap-2 text-sm">
               <input
                 type="checkbox"
                 checked={area.ignoredBoundaries?.includes(boundary.id) || false}
                 onChange={(e) => {
                   const newIgnored = e.target.checked
                     ? [...(area.ignoredBoundaries || []), boundary.id]
                     : (area.ignoredBoundaries || []).filter(id => id !== boundary.id)
                   onUpdate({ ...area, ignoredBoundaries: newIgnored })
                 }}
                 className="rounded border-gray-300"
               />
               <span className="truncate">
                 {boundary.label || `${boundary.type} ${boundary.id.slice(0, 6)}`}
               </span>
             </label>
           ))}
       </div>
     </div>
   )}
   ```

3. **Style notes:**
   - Checkboxes styled with Tailwind
   - Show only boundaries that are currently active (part of boundaryIds) or nearby
   - Truncate long labels
   - Clear explanation text for the feature

**User flow:**
1. Teacher drops area between function and vertical line
2. Area fills up to the line
3. Teacher checks the line in Extend section
4. Area recalculates, now crossing that line to fill adjacent region
  </action>
  <verify>
File exists. TypeScript compiles. Extend section renders when potentialBoundaries is provided.
  </verify>
  <done>
AreaPropertiesPanel has extend mode allowing teacher to ignore specific boundaries.
  </done>
</task>

</tasks>

<verification>
Full integration test:
1. Start dev server: `npm run dev`
2. Open exam builder, add a graph question
3. Add a parabola (x^2) from shape palette
4. Add a linear function (x) from shape palette
5. Add an area from shape palette
6. Drag the area control point between the two curves (around x=0.5)
7. **Expected:** Area fills the region bounded by x^2 and x, from x=0 to x=1

8. Add a vertical line segment at x=0.5
9. Drag area control point to the left of the line (around x=0.3)
10. **Expected:** Area fills only the left portion (x=0 to x=0.5)

11. Select the area, open properties panel
12. In Extend section, check the vertical line
13. **Expected:** Area recalculates to fill entire region (x=0 to x=1), crossing the line

14. Test with horizontal line segment
15. **Expected:** Area bounded by function and horizontal line fills correctly
</verification>

<success_criteria>
1. Area dropped between two functions auto-detects intersection domain
2. Polygon fills correctly between the curves
3. Vertical lines (GraphLine) act as domain boundaries
4. Horizontal lines act as value boundaries
5. Grid lines (background) are NOT treated as boundaries
6. Extend mode allows crossing specific boundaries
7. Dragging control point updates the region
8. Works for various combinations (func+func, func+line, func+multiple lines)
9. No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-area-tool-overhaul/10-03-SUMMARY.md`
</output>

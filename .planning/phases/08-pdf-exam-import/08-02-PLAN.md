---
phase: 08-pdf-exam-import
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - app/api/exam-import/upload/route.ts
  - app/api/exam-import/status/[jobId]/route.ts
autonomous: true

must_haves:
  truths:
    - "Teacher can upload a PDF file and receive a job ID for tracking"
    - "Teacher can poll job status and get exam ID when processing completes"
    - "Invalid files (non-PDF, too large) are rejected with clear error messages"
  artifacts:
    - path: "app/api/exam-import/upload/route.ts"
      provides: "POST endpoint for PDF upload, validation, MinIO storage, BullMQ enqueue"
      exports: ["POST"]
    - path: "app/api/exam-import/status/[jobId]/route.ts"
      provides: "GET endpoint for polling import job status"
      exports: ["GET"]
  key_links:
    - from: "app/api/exam-import/upload/route.ts"
      to: "lib/storage/minio.ts"
      via: "uploadFile for PDF storage"
      pattern: "uploadFile"
    - from: "app/api/exam-import/upload/route.ts"
      to: "lib/queue.ts"
      via: "pdfImportQueue.add to enqueue job"
      pattern: "pdfImportQueue.*add"
    - from: "app/api/exam-import/status/[jobId]/route.ts"
      to: "bullmq"
      via: "Job.fromId to check job state"
      pattern: "Job\\.fromId"
---

<objective>
Create the two API routes for PDF exam import: upload endpoint (validates PDF, stores in MinIO, enqueues BullMQ job) and status polling endpoint (returns job progress and exam ID on completion).

Purpose: These endpoints connect the frontend upload UI to the backend processing pipeline. Without them, the client cannot initiate or track PDF import jobs.

Output: Two API route files following existing patterns from app/api/upload/route.ts (upload) and Phase 5 export status pattern (polling).
</objective>

<execution_context>
@C:\Users\hugol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hugol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-pdf-exam-import/08-RESEARCH.md
@.planning/phases/08-pdf-exam-import/08-01-SUMMARY.md

# Pattern references
@app/api/upload/route.ts
@lib/api-auth.ts
@lib/storage/minio.ts
@lib/queue.ts
@lib/csrf.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PDF upload API route</name>
  <files>app/api/exam-import/upload/route.ts</files>
  <action>
Create `app/api/exam-import/upload/route.ts` following the pattern of `app/api/upload/route.ts`:

POST handler:
1. Authenticate with `getAuthSession(request)` - return 401 if no session
2. Authorize with `isTeacher(session)` - return 403 if not teacher
3. Verify CSRF with `verifyCsrf(request)` - return 403 if invalid (follow existing mutation pattern)
4. Parse FormData, get 'file' field
5. Validate file exists - return 400 "No file provided"
6. Validate file.type === 'application/pdf' - return 400 "Seuls les fichiers PDF sont acceptes"
7. Validate file.size <= 32 * 1024 * 1024 - return 400 "Le PDF depasse la limite de 32 Mo"
8. Get courseId from FormData (required) - return 400 if missing
9. Convert file to Buffer via arrayBuffer()
10. Generate upload key with `generateUploadKey(file.name)` from minio.ts
11. Upload to MinIO via `uploadFile(key, buffer, file.type)` - use default bucket
12. Enqueue job via `pdfImportQueue.add('import-exam', { userId: session.user.id, pdfKey: key, institutionId: session.user.institutionId, courseId })`
13. Return JSON { jobId: job.id, status: 'processing' } with status 200

Error handling: wrap everything in try-catch, log with `[PDF Import] Upload error:`, return 500 on unexpected errors. Check pdfImportQueue is not null (return 503 "Queue not available").

Import pdfImportQueue from '@/lib/queue', uploadFile and generateUploadKey from '@/lib/storage/minio', getAuthSession and isTeacher from '@/lib/api-auth', verifyCsrf from '@/lib/csrf'.
  </action>
  <verify>
`npx tsc --noEmit` passes. File exists at expected path. Verify imports resolve correctly.
  </verify>
  <done>
POST /api/exam-import/upload accepts multipart PDF, validates type/size, stores in MinIO, enqueues BullMQ job, returns jobId. Rejects non-PDF, oversized files, unauthenticated/unauthorized requests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create job status polling API route</name>
  <files>app/api/exam-import/status/[jobId]/route.ts</files>
  <action>
Create `app/api/exam-import/status/[jobId]/route.ts`:

GET handler:
1. Authenticate with `getAuthSession(request)` - return 401 if no session
2. Extract jobId from route params
3. Import `Queue` from 'bullmq' and create a temporary Queue instance connected to 'pdf-import' queue to fetch job status (or import Redis connection from a shared module). Actually, use `Job` from 'bullmq' with `Job.fromId()`:
   - Import Redis from 'ioredis' and create connection (same pattern as worker)
   - Import `Queue` from 'bullmq'
   - Create Queue instance for 'pdf-import' with the Redis connection
   - Get job via `queue.getJob(jobId)`
4. If job not found, return 404 { error: 'Job not found' }
5. Get job state via `job.getState()`
6. If state is 'completed':
   - Get return value via `job.returnvalue` which contains { examId, questionCount, confidence, warnings }
   - Return { status: 'completed', examId: returnValue.examId, questionCount: returnValue.questionCount, confidence: returnValue.confidence, warnings: returnValue.warnings }
7. If state is 'failed':
   - Return { status: 'failed', error: job.failedReason || 'Import echoue' }
8. If state is 'active' or 'waiting' or 'delayed':
   - Return { status: 'processing' }

Important: For the Redis connection, reuse the connection pattern. Create the Queue instance at module level (not per-request) to avoid connection leaks. Use the same REDIS_URL env var pattern as queue.ts.

Error handling: wrap in try-catch, return 500 on unexpected errors.
  </action>
  <verify>
`npx tsc --noEmit` passes. File exists at `app/api/exam-import/status/[jobId]/route.ts`. Dynamic route parameter [jobId] is properly accessed.
  </verify>
  <done>
GET /api/exam-import/status/[jobId] returns job state (processing/completed/failed). On completion, returns examId for client redirect. On failure, returns error message.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Upload route validates PDF type and 32MB size limit
3. Upload route stores in MinIO and enqueues BullMQ job
4. Status route returns correct state transitions (processing -> completed with examId)
5. Both routes require authentication
6. Upload route requires CSRF token (mutation endpoint)
</verification>

<success_criteria>
- Teacher can POST a PDF to /api/exam-import/upload and receive a jobId
- Teacher can GET /api/exam-import/status/{jobId} and see processing -> completed transition
- Non-PDF files rejected with 400
- Files over 32MB rejected with 400
- Unauthenticated requests rejected with 401
- Non-teacher requests rejected with 403
</success_criteria>

<output>
After completion, create `.planning/phases/08-pdf-exam-import/08-02-SUMMARY.md`
</output>

---
phase: 02-exam-creation
plan: 01
type: execute
depends_on: []
files_modified:
  - app/teacher/exams/[examId]/edit/page.tsx
  - components/exam-editor/ExamEditor.tsx
  - components/exam-editor/store.ts
  - components/exam-editor/ExamSidebar.tsx
  - components/exam-editor/AddQuestionButton.tsx
  - lib/actions/exam-editor.ts
autonomous: true

must_haves:
  truths:
    - "Teacher can navigate to /teacher/exams/new and be redirected to a new draft exam"
    - "Exam Editor loads with the exam configuration"
    - "Changes to title/description are saved to local state immediately"
    - "Changes are persisted to DB via autosave or explicit save"
    - "Teacher can add questions via a button with type selection (TEXT/MCQ)"
    - "Running total of points is visible in the editor UI"
  artifacts:
    - path: "components/exam-editor/store.ts"
      provides: "Zustand store for managing exam state during editing"
      exports: ["useExamStore"]
    - path: "app/teacher/exams/[examId]/edit/page.tsx"
      provides: "Main entry point for the editor"
    - path: "components/exam-editor/AddQuestionButton.tsx"
      provides: "Button with dropdown to add questions by type"

key_links:
  - from: "components/exam-editor/ExamEditor.tsx"
    to: "components/exam-editor/store.ts"
    via: "uses store hooks"
  - from: "components/exam-editor/AddQuestionButton.tsx"
    to: "components/exam-editor/store.ts"
    via: "calls addQuestion action with type"
---

<objective>
Establish the core infrastructure for the Exam Editor, including state management, basic metadata editing, and question management workflow.

Purpose: The exam creation experience requires a complex client-side state to handle reordering, drafting questions, and validation before saving. We need a robust shell before building individual question editors.

Output: A functional Exam Editor page where teachers can edit the exam title, description, settings, add questions of different types, and see the total points.
</objective>

<execution_context>
@.planning/phases/02-exam-creation/02-01-PLAN.md
@prisma/schema.prisma
</execution_context>

<tasks>

<task type="auto">
  <name>Task 1: Create Exam Editor Server Actions</name>
  <files>lib/actions/exam-editor.ts</files>
  <action>
Create server actions for managing the exam editor state:

1. `createDraftExam(courseId: string)`:
   - Creates a new Exam with status 'DRAFT'
   - Sets default title "New Exam"
   - Returns the new exam's ID

2. `getExamForEditor(examId: string)`:
   - Fetches Exam with current sections and questions
   - Validates user has permission (author or admin)
   - Returns the full Exam object suitable for the store

3. `updateExamMetadata(examId: string, data: { title?, description?, durationMinutes? })`:
   - Updates the top-level exam properties
   - Revalidates the editor path

4. `addQuestion(examId: string, type: 'TEXT' | 'MCQ', sectionId?: string)`:
   - Creates new Question with the specified type
   - Sets default points to 1
   - Appends to the end of the section/exam
   - Returns the new question object

5. `deleteQuestion(questionId: string)`:
   - Removes question from exam
   - Revalidates editor path
  </action>
  <verify>
Create a test script `scripts/test-exam-actions.ts` that mocks a courseId, creates a draft, adds questions of each type, and fetches it back.
  </verify>
  <done>
Functions exist and handle DB operations correctly using Prisma, including question creation with type selection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Exam Store (Zustand)</name>
  <files>components/exam-editor/store.ts</files>
  <action>
Create a Zustand store to manage the client-side state of the exam editor:

1. State Interface:
   - `exam`: Full exam object (or simplified version for editing)
   - `isDirty`: boolean
   - `isSaving`: boolean
   - `activeSectionId`: string | null
   - `activeQuestionId`: string | null

2. Actions:
   - `initialize(exam: Exam)`: standardizes DB data into store format
   - `updateMetadata(data: Partial<ExamMetadata>)`: updates local state, sets isDirty
   - `setActiveItem(type: 'section' | 'question', id: string)`
   - `addQuestion(question: Question)`: adds question to local state
   - `removeQuestion(questionId: string)`: removes from local state
   - `updateQuestion(questionId: string, data: Partial<Question>)`: updates question in state

3. Computed Values (via selectors or derived state):
   - `totalPoints`: Sum of all question points (for running total display)

4. Use `zustand` and `immer` (if available, else standard spread) for immutability.
  </action>
  <verify>
Unit test the store logic (jest/vitest if setup, or manual console verification). Verify totalPoints updates when questions are added/modified.
  </verify>
  <done>
Store is capable of holding exam state, updating fields, managing questions, and computing total points.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Exam Editor UI Shell with Question Management</name>
  <files>
    app/teacher/exams/[examId]/edit/page.tsx
    components/exam-editor/ExamEditor.tsx
    components/exam-editor/ExamHeader.tsx
    components/exam-editor/ExamSidebar.tsx
    components/exam-editor/AddQuestionButton.tsx
  </files>
  <action>
Implement the main editor layout with question management:

1. `page.tsx`:
   - Server component
   - Await `params`
   - Calls `getExamForEditor(examId)`
   - Renders `<ExamEditor initialData={exam} />`

2. `ExamEditor.tsx` (Client Component):
   - Initializes store with `initialData`
   - Renders `ExamHeader` (Top bar)
   - Renders Main Layout (Sidebar + Content Area)

3. `ExamHeader.tsx`:
   - Inputs for Title (editable in place)
   - **Running Total Display**: Show "Total: X points" badge that reads from store's totalPoints
   - "Save" button (disabled if !isDirty, spinning if isSaving)
   - "Settings" button (opens settings modal/panel)

4. `ExamSidebar.tsx`:
   - List of questions with their type icon and points
   - Click to select (sets activeQuestionId)
   - Delete button on each question
   - **AddQuestionButton at bottom**

5. `AddQuestionButton.tsx`:
   - Button labeled "Add Question"
   - On click: shows dropdown/popover with type options:
     - "Open Question (TEXT)"
     - "Multiple Choice (MCQ)"
   - On selection: calls server action `addQuestion(examId, type)` then updates store

6. Styling:
   - Use Tailwind CSS
   - Sidebar shows question list with type icons
   - Main area for editing current selection
  </action>
  <verify>
Navigate to `/teacher/exams/[id]/edit`. Verify:
1. Title loads and is editable
2. "Add Question" button shows type picker dropdown
3. Adding a TEXT question creates it and shows in sidebar
4. Adding an MCQ question creates it and shows in sidebar
5. Total points badge updates when questions are added
6. Clicking a question in sidebar selects it
  </verify>
  <done>
The editor loads, displays the exam title, allows adding questions via type picker, shows question list in sidebar, and displays running total points.
  </done>
</task>

</tasks>

<verification>
1. Navigate to `/teacher/courses/[courseId]/exams` (or similar entry point).
2. Click "Create Exam" -> triggers `createDraftExam` -> redirects to `/teacher/exams/[newId]/edit`.
3. Verify URL is correct.
4. Verify "New Exam" is displayed in the header.
5. Verify "Total: 0 points" is displayed.
6. Click "Add Question" -> see dropdown with TEXT and MCQ options.
7. Select "Open Question" -> question appears in sidebar with 1 point.
8. Verify "Total: 1 points" updates.
9. Select "Multiple Choice" -> second question appears.
10. Verify "Total: 2 points" updates.
11. Change title to "Midterm 2026".
12. Click Save -> triggers `updateExamMetadata`.
13. Refresh page -> Title remains "Midterm 2026", both questions persist.
</verification>

<success_criteria>
1. Teacher can enter the editor for a new exam.
2. Exam state is correctly loaded from DB into Zustand store.
3. Metadata changes (Title) are persisted to DB.
4. Teacher can add questions using a type picker (TEXT or MCQ).
5. Running total of points is always visible and updates dynamically.
</success_criteria>

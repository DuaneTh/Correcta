---
phase: 05-export
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/export/math-to-svg.ts
  - lib/export/pdf-generator.tsx
  - next.config.ts
autonomous: true

must_haves:
  truths:
    - "MathJax can convert LaTeX to SVG strings on server"
    - "PDF document component renders student answers with math"
    - "react-pdf/renderer is configured for Next.js App Router"
  artifacts:
    - path: "lib/export/math-to-svg.ts"
      provides: "LaTeX to SVG conversion for PDF"
      exports: ["latexToSvg", "parseMathContent"]
    - path: "lib/export/pdf-generator.tsx"
      provides: "React-PDF document component"
      exports: ["ExportDocument", "StudentReportDocument"]
  key_links:
    - from: "lib/export/pdf-generator.tsx"
      to: "lib/export/math-to-svg.ts"
      via: "import latexToSvg"
      pattern: "latexToSvg"
    - from: "next.config.ts"
      to: "@react-pdf/renderer"
      via: "serverComponentsExternalPackages"
      pattern: "react-pdf/renderer"
---

<objective>
Set up PDF generation infrastructure with math rendering.

Purpose: PDF reports require math expressions to render correctly. KaTeX outputs HTML (unsuitable for @react-pdf/renderer), so we use MathJax which produces self-contained SVG. This plan establishes the foundation for PDF export.

Output: Working PDF generation infrastructure with MathJax SVG math rendering, ready for API integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-export/05-RESEARCH.md

Key insights from research:
- @react-pdf/renderer cannot render HTML, needs SVG for math
- MathJax-full produces self-contained SVG strings
- Must add @react-pdf/renderer to serverComponentsExternalPackages in next.config
- Content uses $...$ delimiter for inline math (see lib/content.ts stringToSegments)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install PDF Dependencies</name>
  <files>package.json</files>
  <action>
Install required packages and configure Next.js:

1. Install @react-pdf/renderer and mathjax-full:
```bash
npm install @react-pdf/renderer@^4.3.2 mathjax-full@^4.0.0
```

2. Update `next.config.ts` to add serverComponentsExternalPackages:

Find the existing config and add the external packages array. The config likely looks like:
```typescript
const nextConfig = {
  // existing config...
}
```

Update to include:
```typescript
const nextConfig = {
  // existing config...
  serverExternalPackages: ['@react-pdf/renderer', 'mathjax-full'],
}
```

Note: In Next.js 15, the key is `serverExternalPackages` (not `serverComponentsExternalPackages`).

This prevents bundling issues with these packages in API routes.
  </action>
  <verify>
1. Check package.json includes new dependencies
2. Run `npm install` completes without errors
3. next.config.ts has serverExternalPackages array
  </verify>
  <done>Dependencies installed and Next.js configured for server-side PDF generation</done>
</task>

<task type="auto">
  <name>Task 2: MathJax SVG Converter</name>
  <files>lib/export/math-to-svg.ts</files>
  <action>
Create MathJax server-side LaTeX to SVG converter:

1. Create `lib/export/math-to-svg.ts`:
```typescript
/**
 * MathJax server-side LaTeX to SVG conversion
 *
 * Used for PDF export where KaTeX HTML output is not suitable.
 * MathJax produces self-contained SVG that can be embedded in react-pdf.
 */

import { mathjax } from 'mathjax-full/js/mathjax.js'
import { TeX } from 'mathjax-full/js/input/tex.js'
import { SVG } from 'mathjax-full/js/output/svg.js'
import { liteAdaptor } from 'mathjax-full/js/adaptors/liteAdaptor.js'
import { RegisterHTMLHandler } from 'mathjax-full/js/handlers/html.js'
import { AllPackages } from 'mathjax-full/js/input/tex/AllPackages.js'

// Initialize MathJax once
const adaptor = liteAdaptor()
RegisterHTMLHandler(adaptor)

const tex = new TeX({ packages: AllPackages })
const svg = new SVG({ fontCache: 'none' })  // No font cache for standalone SVG
const html = mathjax.document('', { InputJax: tex, OutputJax: svg })

/**
 * Convert LaTeX string to SVG string
 * @param latex - LaTeX expression (without $ delimiters)
 * @param display - true for display mode (centered), false for inline
 * @returns SVG string or error placeholder
 */
export function latexToSvg(latex: string, display: boolean = false): string {
  try {
    if (!latex || latex.trim() === '') {
      return ''
    }

    const node = html.convert(latex, { display })
    const svgString = adaptor.innerHTML(node)

    // Extract viewBox and dimensions for react-pdf Svg component
    return svgString
  } catch (error) {
    console.error('[MathJax] Error converting LaTeX:', latex, error)
    // Return placeholder for failed conversion
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><text x="5" y="15" fill="red" font-size="12">[Math Error]</text></svg>`
  }
}

/**
 * Parse content string with $...$ math delimiters
 * Returns array of parts with type 'text' or 'math'
 */
export interface ContentPart {
  type: 'text' | 'math'
  content: string
}

export function parseMathContent(content: string): ContentPart[] {
  if (!content) return []

  const parts: ContentPart[] = []
  // Match both $...$ (inline) and $$...$$ (display) - display first to avoid partial matches
  const regex = /\$\$([^$]+)\$\$|\$([^$]+)\$/g
  let lastIndex = 0
  let match: RegExpExecArray | null

  while ((match = regex.exec(content)) !== null) {
    // Add text before match
    if (match.index > lastIndex) {
      const text = content.slice(lastIndex, match.index)
      if (text) {
        parts.push({ type: 'text', content: text })
      }
    }

    // Add math part (match[1] is display $$, match[2] is inline $)
    const latex = match[1] ?? match[2] ?? ''
    if (latex) {
      parts.push({ type: 'math', content: latex })
    }

    lastIndex = regex.lastIndex
  }

  // Add remaining text
  if (lastIndex < content.length) {
    const text = content.slice(lastIndex)
    if (text) {
      parts.push({ type: 'text', content: text })
    }
  }

  return parts.length > 0 ? parts : [{ type: 'text', content: content }]
}

/**
 * Extract SVG dimensions from SVG string for react-pdf sizing
 */
export function extractSvgDimensions(svgString: string): { width: number; height: number } {
  // MathJax SVGs have width/height in ex units, we need to convert
  const widthMatch = svgString.match(/width="([0-9.]+)ex"/)
  const heightMatch = svgString.match(/height="([0-9.]+)ex"/)

  // 1ex ~= 8px at 12pt font
  const exToPx = 8
  const width = widthMatch ? parseFloat(widthMatch[1]) * exToPx : 50
  const height = heightMatch ? parseFloat(heightMatch[1]) * exToPx : 20

  return { width, height }
}
```

Key decisions:
- Use AllPackages for broad LaTeX support (same as student input)
- fontCache: 'none' for self-contained SVG (no external font references)
- Error handling returns visible placeholder instead of crashing
- Parse both inline ($...$) and display ($$...$$) math
  </action>
  <verify>
Create a test script to verify MathJax works:
```bash
npx tsx -e "
const { latexToSvg } = require('./lib/export/math-to-svg.ts');
const svg = latexToSvg('\\\\frac{1}{2}');
console.log('SVG length:', svg.length);
console.log('Contains svg tag:', svg.includes('<svg'));
"
```
  </verify>
  <done>MathJax converts LaTeX to SVG strings on server</done>
</task>

<task type="auto">
  <name>Task 3: PDF Document Component</name>
  <files>lib/export/pdf-generator.tsx</files>
  <action>
Create React-PDF document component for grade reports:

1. Create `lib/export/pdf-generator.tsx`:
```typescript
import React from 'react'
import {
  Document,
  Page,
  Text,
  View,
  StyleSheet,
  Svg,
  G,
  Path,
  Rect,
  Line
} from '@react-pdf/renderer'
import { latexToSvg, parseMathContent, extractSvgDimensions } from './math-to-svg'
import { parseContent, segmentsToPlainText } from '@/lib/content'
import type { ContentSegment } from '@/types/exams'

// PDF styles
const styles = StyleSheet.create({
  page: {
    padding: 40,
    fontSize: 11,
    fontFamily: 'Helvetica'
  },
  header: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center'
  },
  subheader: {
    fontSize: 14,
    marginBottom: 10,
    color: '#374151'
  },
  studentInfo: {
    marginBottom: 20,
    padding: 10,
    backgroundColor: '#f3f4f6',
    borderRadius: 4
  },
  studentName: {
    fontSize: 14,
    fontWeight: 'bold'
  },
  studentEmail: {
    fontSize: 10,
    color: '#6b7280'
  },
  totalScore: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#4f46e5',
    marginTop: 5
  },
  question: {
    marginBottom: 15,
    paddingBottom: 10,
    borderBottom: '1px solid #e5e7eb'
  },
  questionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8
  },
  questionLabel: {
    fontSize: 12,
    fontWeight: 'bold',
    color: '#1f2937'
  },
  questionScore: {
    fontSize: 12,
    fontWeight: 'bold'
  },
  scoreGood: {
    color: '#059669'
  },
  scoreMedium: {
    color: '#d97706'
  },
  scoreLow: {
    color: '#dc2626'
  },
  contentLabel: {
    fontSize: 9,
    color: '#6b7280',
    marginTop: 8,
    marginBottom: 4
  },
  answerBox: {
    backgroundColor: '#fafafa',
    padding: 8,
    borderRadius: 4,
    marginTop: 4
  },
  feedback: {
    marginTop: 8,
    padding: 8,
    backgroundColor: '#eff6ff',
    borderRadius: 4,
    borderLeft: '3px solid #3b82f6'
  },
  feedbackLabel: {
    fontSize: 9,
    fontWeight: 'bold',
    color: '#1d4ed8',
    marginBottom: 4
  },
  feedbackText: {
    fontSize: 10,
    color: '#1e40af',
    fontStyle: 'italic'
  },
  text: {
    fontSize: 11,
    lineHeight: 1.4
  },
  mathContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    alignItems: 'center'
  },
  footer: {
    position: 'absolute',
    bottom: 30,
    left: 40,
    right: 40,
    fontSize: 9,
    color: '#9ca3af',
    textAlign: 'center'
  }
})

// Types
export interface QuestionExportData {
  id: string
  order: number
  sectionOrder: number
  content: string  // JSON string of ContentSegment[]
  maxPoints: number
  studentAnswer: string  // Plain text or LaTeX string
  score: number | null
  feedback: string | null
}

export interface AttemptExportData {
  id: string
  student: {
    name: string
    email: string
  }
  submittedAt: string | null
  totalScore: number
  maxPoints: number
  questions: QuestionExportData[]
}

export interface ExportDocumentProps {
  exam: {
    title: string
    description?: string | null
  }
  attempts: AttemptExportData[]
  generatedAt: string
}

/**
 * Render content with math as Text + SVG components
 */
function MathContent({ content }: { content: string }) {
  // For complex content (JSON segments), convert to plain text first
  let textContent = content
  try {
    const parsed = JSON.parse(content)
    if (Array.isArray(parsed)) {
      textContent = segmentsToPlainText(parsed as ContentSegment[])
    }
  } catch {
    // Not JSON, use as-is
  }

  const parts = parseMathContent(textContent)

  return (
    <View style={styles.mathContainer}>
      {parts.map((part, idx) => {
        if (part.type === 'math') {
          return <MathSvg key={idx} latex={part.content} />
        }
        return <Text key={idx} style={styles.text}>{part.content}</Text>
      })}
    </View>
  )
}

/**
 * Render LaTeX as SVG using MathJax
 */
function MathSvg({ latex }: { latex: string }) {
  const svgString = latexToSvg(latex, false)

  if (!svgString || svgString === '') {
    return <Text style={styles.text}>{latex}</Text>
  }

  const { width, height } = extractSvgDimensions(svgString)

  // Parse SVG and render using react-pdf primitives
  // For simplicity, we render as an inline placeholder
  // Full SVG parsing would require a dedicated parser
  return (
    <View style={{ width, height, marginHorizontal: 2 }}>
      <Text style={{ fontSize: 10, color: '#4f46e5' }}>[{latex}]</Text>
    </View>
  )
}

/**
 * Get score color based on percentage
 */
function getScoreStyle(score: number, maxPoints: number) {
  if (maxPoints === 0) return styles.text
  const percentage = (score / maxPoints) * 100
  if (percentage >= 70) return styles.scoreGood
  if (percentage >= 40) return styles.scoreMedium
  return styles.scoreLow
}

/**
 * Single student report page
 */
function StudentReport({ exam, attempt }: { exam: ExportDocumentProps['exam']; attempt: AttemptExportData }) {
  const scorePercentage = attempt.maxPoints > 0
    ? Math.round((attempt.totalScore / attempt.maxPoints) * 100)
    : 0

  return (
    <Page size="A4" style={styles.page}>
      {/* Header */}
      <Text style={styles.header}>{exam.title}</Text>

      {/* Student info */}
      <View style={styles.studentInfo}>
        <Text style={styles.studentName}>{attempt.student.name}</Text>
        <Text style={styles.studentEmail}>{attempt.student.email}</Text>
        <Text style={[styles.totalScore, getScoreStyle(attempt.totalScore, attempt.maxPoints)]}>
          Score: {attempt.totalScore} / {attempt.maxPoints} ({scorePercentage}%)
        </Text>
      </View>

      {/* Questions */}
      {attempt.questions.map((q, idx) => (
        <View key={q.id} style={styles.question} wrap={false}>
          <View style={styles.questionHeader}>
            <Text style={styles.questionLabel}>
              Question {q.sectionOrder}.{q.order + 1}
            </Text>
            <Text style={[styles.questionScore, q.score !== null ? getScoreStyle(q.score, q.maxPoints) : {}]}>
              {q.score !== null ? `${q.score} / ${q.maxPoints}` : 'Non note'}
            </Text>
          </View>

          {/* Student answer */}
          <Text style={styles.contentLabel}>Reponse de l&apos;etudiant</Text>
          <View style={styles.answerBox}>
            <MathContent content={q.studentAnswer || '(Pas de reponse)'} />
          </View>

          {/* Feedback */}
          {q.feedback && (
            <View style={styles.feedback}>
              <Text style={styles.feedbackLabel}>Commentaire</Text>
              <Text style={styles.feedbackText}>{q.feedback}</Text>
            </View>
          )}
        </View>
      ))}

      {/* Footer */}
      <Text style={styles.footer} fixed>
        Genere par Correcta - {attempt.submittedAt ? new Date(attempt.submittedAt).toLocaleDateString('fr-FR') : ''}
      </Text>
    </Page>
  )
}

/**
 * Full export document with all students
 */
export function ExportDocument({ exam, attempts, generatedAt }: ExportDocumentProps) {
  return (
    <Document>
      {attempts.map(attempt => (
        <StudentReport key={attempt.id} exam={exam} attempt={attempt} />
      ))}
    </Document>
  )
}

/**
 * Single student report document
 */
export function StudentReportDocument({ exam, attempt }: { exam: ExportDocumentProps['exam']; attempt: AttemptExportData }) {
  return (
    <Document>
      <StudentReport exam={exam} attempt={attempt} />
    </Document>
  )
}
```

Key decisions:
- One page per student (wrap={false} keeps questions together)
- Color-coded scores (green >70%, orange 40-70%, red <40%)
- Math rendering uses placeholder for now (full SVG parsing is complex)
- French labels throughout (Reponse, Commentaire, etc.)
- Footer with generation date
  </action>
  <verify>
TypeScript compilation:
```bash
npx tsc --noEmit lib/export/pdf-generator.tsx
```
  </verify>
  <done>PDF document component compiles and exports ExportDocument and StudentReportDocument</done>
</task>

</tasks>

<verification>
1. `npm install` completes without errors
2. `npx tsc --noEmit lib/export/math-to-svg.ts` - no errors
3. `npx tsc --noEmit lib/export/pdf-generator.tsx` - no errors
4. next.config.ts includes serverExternalPackages array with @react-pdf/renderer
5. MathJax test produces valid SVG output
</verification>

<success_criteria>
1. @react-pdf/renderer and mathjax-full are installed
2. latexToSvg function converts LaTeX to SVG strings
3. ExportDocument component renders without errors
4. next.config.ts is configured for server-side PDF generation
</success_criteria>

<output>
After completion, create `.planning/phases/05-export/05-02-SUMMARY.md`
</output>

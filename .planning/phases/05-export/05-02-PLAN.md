---
phase: 05-export
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/export/math-to-svg.ts
  - lib/export/pdf-generator.tsx
  - next.config.ts
autonomous: true

must_haves:
  truths:
    - "Math expressions in PDF display correctly (not placeholders)"
    - "PDF document renders student answers with formatted math"
    - "LaTeX like $\\frac{1}{2}$ appears as proper fraction in PDF"
  artifacts:
    - path: "lib/export/math-to-svg.ts"
      provides: "LaTeX to SVG conversion and SVG parsing for react-pdf"
      exports: ["latexToSvg", "parseMathContent", "svgToReactPdf"]
    - path: "lib/export/pdf-generator.tsx"
      provides: "React-PDF document component with math rendering"
      exports: ["ExportDocument", "StudentReportDocument"]
  key_links:
    - from: "lib/export/pdf-generator.tsx"
      to: "lib/export/math-to-svg.ts"
      via: "import latexToSvg, svgToReactPdf"
      pattern: "svgToReactPdf"
    - from: "next.config.ts"
      to: "@react-pdf/renderer"
      via: "serverComponentsExternalPackages"
      pattern: "react-pdf/renderer"
---

<objective>
Set up PDF generation infrastructure with working math rendering.

Purpose: PDF reports require math expressions to render correctly. KaTeX outputs HTML (unsuitable for @react-pdf/renderer), so we use MathJax which produces self-contained SVG. The SVG output is then parsed and rendered using react-pdf's Svg primitives.

Output: Working PDF generation infrastructure where math expressions (like $\frac{1}{2}$) render as actual formatted math, not placeholders.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-export/05-RESEARCH.md

Key insights from research:
- @react-pdf/renderer cannot render HTML, needs SVG primitives (Svg, Path, G, Rect, etc.)
- MathJax-full produces self-contained SVG strings
- Must add @react-pdf/renderer to serverExternalPackages in next.config
- Content uses $...$ delimiter for inline math (see lib/content.ts stringToSegments)
- Open question from research: "Exact parsing/transformation needed to convert MathJax SVG output to react-pdf primitives" - THIS PLAN RESOLVES IT
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install PDF and SVG Parsing Dependencies</name>
  <files>package.json, next.config.ts</files>
  <action>
Install required packages and configure Next.js:

1. Install @react-pdf/renderer, mathjax-full, and svg-parser:
```bash
npm install @react-pdf/renderer@^4.3.2 mathjax-full@^4.0.0 svg-parser@^2.0.4
npm install --save-dev @types/svg-parser
```

**Why svg-parser:** MathJax outputs SVG strings. react-pdf cannot render raw SVG strings - it needs React components (Svg, Path, G, etc.). svg-parser converts SVG string to AST that we can transform to react-pdf elements.

2. Update `next.config.ts` to add serverExternalPackages:

Find the existing config and add the external packages array. The config likely looks like:
```typescript
const nextConfig = {
  // existing config...
}
```

Update to include:
```typescript
const nextConfig = {
  // existing config...
  serverExternalPackages: ['@react-pdf/renderer', 'mathjax-full'],
}
```

Note: In Next.js 15, the key is `serverExternalPackages` (not `serverComponentsExternalPackages`).

This prevents bundling issues with these packages in API routes.
  </action>
  <verify>
1. Check package.json includes new dependencies: @react-pdf/renderer, mathjax-full, svg-parser
2. Run `npm install` completes without errors
3. next.config.ts has serverExternalPackages array
  </verify>
  <done>Dependencies installed (including svg-parser) and Next.js configured for server-side PDF generation</done>
</task>

<task type="auto">
  <name>Task 2: MathJax SVG Converter with react-pdf Transformation</name>
  <files>lib/export/math-to-svg.ts</files>
  <action>
Create MathJax server-side LaTeX to SVG converter WITH react-pdf transformation:

1. Create `lib/export/math-to-svg.ts`:
```typescript
/**
 * MathJax server-side LaTeX to SVG conversion + react-pdf transformation
 *
 * Used for PDF export where KaTeX HTML output is not suitable.
 * MathJax produces self-contained SVG, which we parse and convert
 * to react-pdf Svg primitives (Svg, G, Path, Rect, etc.).
 */

import { mathjax } from 'mathjax-full/js/mathjax.js'
import { TeX } from 'mathjax-full/js/input/tex.js'
import { SVG } from 'mathjax-full/js/output/svg.js'
import { liteAdaptor } from 'mathjax-full/js/adaptors/liteAdaptor.js'
import { RegisterHTMLHandler } from 'mathjax-full/js/handlers/html.js'
import { AllPackages } from 'mathjax-full/js/input/tex/AllPackages.js'
import { parse as parseSvg, type RootNode, type ElementNode, type TextNode } from 'svg-parser'
import React from 'react'
import {
  Svg,
  G,
  Path,
  Rect,
  Line,
  Circle,
  Ellipse,
  Polygon,
  Polyline,
  Text as SvgText,
  Defs,
  Use,
  ClipPath,
} from '@react-pdf/renderer'

// Initialize MathJax once (module-level singleton)
const adaptor = liteAdaptor()
RegisterHTMLHandler(adaptor)

const tex = new TeX({ packages: AllPackages })
const svg = new SVG({ fontCache: 'none' })  // No font cache for standalone SVG
const html = mathjax.document('', { InputJax: tex, OutputJax: svg })

/**
 * Convert LaTeX string to SVG string
 * @param latex - LaTeX expression (without $ delimiters)
 * @param display - true for display mode (centered), false for inline
 * @returns SVG string or error placeholder
 */
export function latexToSvg(latex: string, display: boolean = false): string {
  try {
    if (!latex || latex.trim() === '') {
      return ''
    }

    const node = html.convert(latex, { display })
    const svgString = adaptor.innerHTML(node)

    return svgString
  } catch (error) {
    console.error('[MathJax] Error converting LaTeX:', latex, error)
    // Return placeholder for failed conversion
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><text x="5" y="15" fill="red" font-size="12">[Math Error]</text></svg>`
  }
}

/**
 * Parse content string with $...$ math delimiters
 * Returns array of parts with type 'text' or 'math'
 */
export interface ContentPart {
  type: 'text' | 'math'
  content: string
}

export function parseMathContent(content: string): ContentPart[] {
  if (!content) return []

  const parts: ContentPart[] = []
  // Match both $...$ (inline) and $$...$$ (display) - display first to avoid partial matches
  const regex = /\$\$([^$]+)\$\$|\$([^$]+)\$/g
  let lastIndex = 0
  let match: RegExpExecArray | null

  while ((match = regex.exec(content)) !== null) {
    // Add text before match
    if (match.index > lastIndex) {
      const text = content.slice(lastIndex, match.index)
      if (text) {
        parts.push({ type: 'text', content: text })
      }
    }

    // Add math part (match[1] is display $$, match[2] is inline $)
    const latex = match[1] ?? match[2] ?? ''
    if (latex) {
      parts.push({ type: 'math', content: latex })
    }

    lastIndex = regex.lastIndex
  }

  // Add remaining text
  if (lastIndex < content.length) {
    const text = content.slice(lastIndex)
    if (text) {
      parts.push({ type: 'text', content: text })
    }
  }

  return parts.length > 0 ? parts : [{ type: 'text', content: content }]
}

/**
 * Extract SVG dimensions from SVG string for react-pdf sizing
 */
export function extractSvgDimensions(svgString: string): { width: number; height: number; viewBox?: string } {
  // MathJax SVGs have width/height in ex units, we need to convert
  const widthMatch = svgString.match(/width="([0-9.]+)ex"/)
  const heightMatch = svgString.match(/height="([0-9.]+)ex"/)
  const viewBoxMatch = svgString.match(/viewBox="([^"]+)"/)

  // 1ex ~= 8px at 12pt font (standard approximation)
  const exToPx = 8
  const width = widthMatch ? parseFloat(widthMatch[1]) * exToPx : 50
  const height = heightMatch ? parseFloat(heightMatch[1]) * exToPx : 20
  const viewBox = viewBoxMatch ? viewBoxMatch[1] : undefined

  return { width, height, viewBox }
}

/**
 * Convert parsed SVG AST node to react-pdf element
 * This is the core transformation from svg-parser output to react-pdf components
 */
function astNodeToReactPdf(node: ElementNode | TextNode, key: number): React.ReactElement | string | null {
  // Handle text nodes
  if (node.type === 'text') {
    return (node as TextNode).value || null
  }

  const elem = node as ElementNode
  const tagName = elem.tagName
  const props: Record<string, any> = { key }

  // Convert attributes to props
  if (elem.properties) {
    for (const [attr, value] of Object.entries(elem.properties)) {
      // Convert hyphenated attributes to camelCase for react-pdf
      const propName = attr.replace(/-([a-z])/g, (_, c) => c.toUpperCase())

      // Skip certain attributes that don't apply to react-pdf
      if (['xmlns', 'xmlns:xlink', 'xml:space', 'version'].includes(attr)) {
        continue
      }

      // Handle special attribute mappings
      if (attr === 'xlink:href') {
        props['xlinkHref'] = value
      } else if (attr === 'class') {
        // Skip class attributes (react-pdf uses style objects)
        continue
      } else if (attr === 'style' && typeof value === 'string') {
        // Parse inline style string to object
        const styleObj: Record<string, string> = {}
        value.split(';').forEach(rule => {
          const [prop, val] = rule.split(':').map(s => s.trim())
          if (prop && val) {
            const camelProp = prop.replace(/-([a-z])/g, (_, c) => c.toUpperCase())
            styleObj[camelProp] = val
          }
        })
        props['style'] = styleObj
      } else {
        props[propName] = value
      }
    }
  }

  // Recursively process children
  const children = elem.children
    ?.map((child, idx) => astNodeToReactPdf(child as ElementNode | TextNode, idx))
    .filter(Boolean) || []

  // Map SVG tags to react-pdf components
  switch (tagName) {
    case 'svg':
      // For nested SVG, use G group instead
      return React.createElement(G, props, ...children)
    case 'g':
      return React.createElement(G, props, ...children)
    case 'path':
      return React.createElement(Path, props)
    case 'rect':
      return React.createElement(Rect, props)
    case 'line':
      return React.createElement(Line, props)
    case 'circle':
      return React.createElement(Circle, props)
    case 'ellipse':
      return React.createElement(Ellipse, props)
    case 'polygon':
      return React.createElement(Polygon, props)
    case 'polyline':
      return React.createElement(Polyline, props)
    case 'text':
      return React.createElement(SvgText, props, ...children)
    case 'tspan':
      // react-pdf doesn't have Tspan, render content directly
      return children.length > 0 ? children[0] : null
    case 'defs':
      return React.createElement(Defs, props, ...children)
    case 'use':
      return React.createElement(Use, props)
    case 'clipPath':
      return React.createElement(ClipPath, props, ...children)
    case 'title':
    case 'desc':
      // Skip metadata elements
      return null
    default:
      // For unknown elements, try to render as G with children
      if (children.length > 0) {
        return React.createElement(G, props, ...children)
      }
      return null
  }
}

/**
 * Convert SVG string to react-pdf Svg component
 * This is the main function used by pdf-generator.tsx
 */
export function svgToReactPdf(svgString: string): React.ReactElement | null {
  if (!svgString || svgString.trim() === '') {
    return null
  }

  try {
    // Parse SVG string to AST
    const parsed = parseSvg(svgString)

    if (!parsed.children || parsed.children.length === 0) {
      return null
    }

    // Find the root SVG element
    const svgRoot = parsed.children.find(
      (child): child is ElementNode =>
        child.type === 'element' && child.tagName === 'svg'
    )

    if (!svgRoot) {
      return null
    }

    // Extract dimensions
    const { width, height, viewBox } = extractSvgDimensions(svgString)

    // Build props for root Svg element
    const svgProps: Record<string, any> = {
      width,
      height,
    }

    if (viewBox) {
      svgProps.viewBox = viewBox
    }

    // Convert children
    const children = svgRoot.children
      ?.map((child, idx) => astNodeToReactPdf(child as ElementNode | TextNode, idx))
      .filter(Boolean) || []

    return React.createElement(Svg, svgProps, ...children)
  } catch (error) {
    console.error('[svgToReactPdf] Error parsing SVG:', error)
    return null
  }
}

/**
 * Convert LaTeX directly to react-pdf Svg element
 * Convenience function combining latexToSvg + svgToReactPdf
 */
export function latexToReactPdf(latex: string, display: boolean = false): React.ReactElement | null {
  const svgString = latexToSvg(latex, display)
  return svgToReactPdf(svgString)
}
```

Key decisions:
- Use AllPackages for broad LaTeX support (same as student input)
- fontCache: 'none' for self-contained SVG (no external font references)
- Error handling returns visible placeholder instead of crashing
- Parse both inline ($...$) and display ($$...$$) math
- **NEW:** Full SVG-to-react-pdf transformation using svg-parser
- Handles all common SVG elements: path, g, rect, line, circle, etc.
- Converts hyphenated attributes to camelCase for React
- Skips metadata elements (title, desc) that don't render
  </action>
  <verify>
Create a test script to verify both MathJax conversion AND react-pdf transformation:
```bash
npx tsx -e "
import { latexToSvg, svgToReactPdf } from './lib/export/math-to-svg';
const svg = latexToSvg('\\\\frac{1}{2}');
console.log('SVG length:', svg.length);
console.log('Contains svg tag:', svg.includes('<svg'));
console.log('Contains path tag:', svg.includes('<path'));
const reactPdfElement = svgToReactPdf(svg);
console.log('React element type:', reactPdfElement?.type?.name || reactPdfElement?.type);
console.log('Has children:', !!reactPdfElement?.props?.children);
"
```
  </verify>
  <done>MathJax converts LaTeX to SVG strings, svgToReactPdf transforms SVG to react-pdf elements</done>
</task>

<task type="auto">
  <name>Task 3: PDF Document Component with Working Math</name>
  <files>lib/export/pdf-generator.tsx</files>
  <action>
Create React-PDF document component with WORKING math rendering (not placeholders):

1. Create `lib/export/pdf-generator.tsx`:
```typescript
import React from 'react'
import {
  Document,
  Page,
  Text,
  View,
  StyleSheet,
} from '@react-pdf/renderer'
import { latexToReactPdf, parseMathContent, extractSvgDimensions, latexToSvg } from './math-to-svg'
import { parseContent, segmentsToPlainText } from '@/lib/content'
import type { ContentSegment } from '@/types/exams'

// PDF styles
const styles = StyleSheet.create({
  page: {
    padding: 40,
    fontSize: 11,
    fontFamily: 'Helvetica'
  },
  header: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center'
  },
  subheader: {
    fontSize: 14,
    marginBottom: 10,
    color: '#374151'
  },
  studentInfo: {
    marginBottom: 20,
    padding: 10,
    backgroundColor: '#f3f4f6',
    borderRadius: 4
  },
  studentName: {
    fontSize: 14,
    fontWeight: 'bold'
  },
  studentEmail: {
    fontSize: 10,
    color: '#6b7280'
  },
  totalScore: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#4f46e5',
    marginTop: 5
  },
  question: {
    marginBottom: 15,
    paddingBottom: 10,
    borderBottom: '1px solid #e5e7eb'
  },
  questionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8
  },
  questionLabel: {
    fontSize: 12,
    fontWeight: 'bold',
    color: '#1f2937'
  },
  questionScore: {
    fontSize: 12,
    fontWeight: 'bold'
  },
  scoreGood: {
    color: '#059669'
  },
  scoreMedium: {
    color: '#d97706'
  },
  scoreLow: {
    color: '#dc2626'
  },
  contentLabel: {
    fontSize: 9,
    color: '#6b7280',
    marginTop: 8,
    marginBottom: 4
  },
  answerBox: {
    backgroundColor: '#fafafa',
    padding: 8,
    borderRadius: 4,
    marginTop: 4
  },
  feedback: {
    marginTop: 8,
    padding: 8,
    backgroundColor: '#eff6ff',
    borderRadius: 4,
    borderLeft: '3px solid #3b82f6'
  },
  feedbackLabel: {
    fontSize: 9,
    fontWeight: 'bold',
    color: '#1d4ed8',
    marginBottom: 4
  },
  feedbackText: {
    fontSize: 10,
    color: '#1e40af',
    fontStyle: 'italic'
  },
  text: {
    fontSize: 11,
    lineHeight: 1.4
  },
  mathContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    alignItems: 'center'
  },
  mathInline: {
    marginHorizontal: 2,
    marginVertical: 1
  },
  footer: {
    position: 'absolute',
    bottom: 30,
    left: 40,
    right: 40,
    fontSize: 9,
    color: '#9ca3af',
    textAlign: 'center'
  }
})

// Types
export interface QuestionExportData {
  id: string
  order: number
  sectionOrder: number
  content: string  // JSON string of ContentSegment[]
  maxPoints: number
  studentAnswer: string  // Plain text or LaTeX string
  score: number | null
  feedback: string | null
}

export interface AttemptExportData {
  id: string
  student: {
    name: string
    email: string
  }
  submittedAt: string | null
  totalScore: number
  maxPoints: number
  questions: QuestionExportData[]
}

export interface ExportDocumentProps {
  exam: {
    title: string
    description?: string | null
  }
  attempts: AttemptExportData[]
  generatedAt: string
}

/**
 * Render LaTeX as actual SVG using MathJax + react-pdf transformation
 * NOT a placeholder - renders real formatted math
 */
function MathSvg({ latex }: { latex: string }) {
  // Convert LaTeX to react-pdf Svg element
  const svgElement = latexToReactPdf(latex, false)

  if (!svgElement) {
    // Fallback: show LaTeX source if conversion fails
    return <Text style={{ fontSize: 10, color: '#6b7280' }}>[{latex}]</Text>
  }

  // Get dimensions for proper sizing
  const svgString = latexToSvg(latex, false)
  const { width, height } = extractSvgDimensions(svgString)

  return (
    <View style={[styles.mathInline, { width, height }]}>
      {svgElement}
    </View>
  )
}

/**
 * Render content with math as Text + SVG components
 */
function MathContent({ content }: { content: string }) {
  // For complex content (JSON segments), convert to plain text first
  let textContent = content
  try {
    const parsed = JSON.parse(content)
    if (Array.isArray(parsed)) {
      textContent = segmentsToPlainText(parsed as ContentSegment[])
    }
  } catch {
    // Not JSON, use as-is
  }

  const parts = parseMathContent(textContent)

  // If no math, render as simple text
  if (parts.every(p => p.type === 'text')) {
    return <Text style={styles.text}>{textContent}</Text>
  }

  return (
    <View style={styles.mathContainer}>
      {parts.map((part, idx) => {
        if (part.type === 'math') {
          return <MathSvg key={idx} latex={part.content} />
        }
        return <Text key={idx} style={styles.text}>{part.content}</Text>
      })}
    </View>
  )
}

/**
 * Get score color based on percentage
 */
function getScoreStyle(score: number, maxPoints: number) {
  if (maxPoints === 0) return styles.text
  const percentage = (score / maxPoints) * 100
  if (percentage >= 70) return styles.scoreGood
  if (percentage >= 40) return styles.scoreMedium
  return styles.scoreLow
}

/**
 * Single student report page
 */
function StudentReport({ exam, attempt }: { exam: ExportDocumentProps['exam']; attempt: AttemptExportData }) {
  const scorePercentage = attempt.maxPoints > 0
    ? Math.round((attempt.totalScore / attempt.maxPoints) * 100)
    : 0

  return (
    <Page size="A4" style={styles.page}>
      {/* Header */}
      <Text style={styles.header}>{exam.title}</Text>

      {/* Student info */}
      <View style={styles.studentInfo}>
        <Text style={styles.studentName}>{attempt.student.name}</Text>
        <Text style={styles.studentEmail}>{attempt.student.email}</Text>
        <Text style={[styles.totalScore, getScoreStyle(attempt.totalScore, attempt.maxPoints)]}>
          Score: {attempt.totalScore} / {attempt.maxPoints} ({scorePercentage}%)
        </Text>
      </View>

      {/* Questions */}
      {attempt.questions.map((q, idx) => (
        <View key={q.id} style={styles.question} wrap={false}>
          <View style={styles.questionHeader}>
            <Text style={styles.questionLabel}>
              Question {q.sectionOrder}.{q.order + 1}
            </Text>
            <Text style={[styles.questionScore, q.score !== null ? getScoreStyle(q.score, q.maxPoints) : {}]}>
              {q.score !== null ? `${q.score} / ${q.maxPoints}` : 'Non note'}
            </Text>
          </View>

          {/* Student answer */}
          <Text style={styles.contentLabel}>Reponse de l&apos;etudiant</Text>
          <View style={styles.answerBox}>
            <MathContent content={q.studentAnswer || '(Pas de reponse)'} />
          </View>

          {/* Feedback */}
          {q.feedback && (
            <View style={styles.feedback}>
              <Text style={styles.feedbackLabel}>Commentaire</Text>
              <Text style={styles.feedbackText}>{q.feedback}</Text>
            </View>
          )}
        </View>
      ))}

      {/* Footer */}
      <Text style={styles.footer} fixed>
        Genere par Correcta - {attempt.submittedAt ? new Date(attempt.submittedAt).toLocaleDateString('fr-FR') : ''}
      </Text>
    </Page>
  )
}

/**
 * Full export document with all students
 */
export function ExportDocument({ exam, attempts, generatedAt }: ExportDocumentProps) {
  return (
    <Document>
      {attempts.map(attempt => (
        <StudentReport key={attempt.id} exam={exam} attempt={attempt} />
      ))}
    </Document>
  )
}

/**
 * Single student report document
 */
export function StudentReportDocument({ exam, attempt }: { exam: ExportDocumentProps['exam']; attempt: AttemptExportData }) {
  return (
    <Document>
      <StudentReport exam={exam} attempt={attempt} />
    </Document>
  )
}
```

Key changes from placeholder version:
- **MathSvg now renders ACTUAL SVG:** Uses latexToReactPdf() which converts LaTeX -> MathJax SVG -> react-pdf Svg elements
- **Proper dimensions:** Extracts width/height from MathJax output for correct sizing
- **Graceful fallback:** If SVG conversion fails, shows LaTeX source (not empty)
- French labels throughout (Reponse, Commentaire, etc.)
- Color-coded scores (green >70%, orange 40-70%, red <40%)
- One page per student (wrap={false} keeps questions together)
  </action>
  <verify>
TypeScript compilation:
```bash
npx tsc --noEmit lib/export/pdf-generator.tsx
```

Integration test (requires worker running, but compilation confirms structure):
```bash
npx tsx -e "
import { ExportDocument } from './lib/export/pdf-generator';
import { renderToBuffer } from '@react-pdf/renderer';
import React from 'react';

const testData = {
  exam: { title: 'Test Exam' },
  attempts: [{
    id: '1',
    student: { name: 'Test Student', email: 'test@example.com' },
    submittedAt: new Date().toISOString(),
    totalScore: 8,
    maxPoints: 10,
    questions: [{
      id: 'q1',
      order: 0,
      sectionOrder: 1,
      content: 'What is \$\\\\frac{1}{2} + \\\\frac{1}{4}\$?',
      maxPoints: 10,
      studentAnswer: '\$\\\\frac{3}{4}\$',
      score: 8,
      feedback: 'Good work!'
    }]
  }],
  generatedAt: new Date().toISOString()
};

renderToBuffer(React.createElement(ExportDocument, testData))
  .then(buffer => console.log('PDF generated successfully:', buffer.length, 'bytes'))
  .catch(err => console.error('PDF generation failed:', err.message));
"
```
  </verify>
  <done>PDF document component renders math expressions as actual formatted SVG, not placeholders</done>
</task>

</tasks>

<verification>
1. `npm install` completes without errors
2. `npx tsc --noEmit lib/export/math-to-svg.ts` - no errors
3. `npx tsc --noEmit lib/export/pdf-generator.tsx` - no errors
4. next.config.ts includes serverExternalPackages array with @react-pdf/renderer
5. MathJax test produces valid SVG output with path elements
6. svgToReactPdf transforms SVG string to react-pdf Svg element
7. Integration test generates PDF buffer without errors
</verification>

<success_criteria>
1. @react-pdf/renderer, mathjax-full, and svg-parser are installed
2. latexToSvg function converts LaTeX to SVG strings with path elements
3. svgToReactPdf transforms SVG strings to react-pdf Svg elements (not placeholders!)
4. ExportDocument component renders without errors
5. Math expressions like $\frac{1}{2}$ appear as actual formatted fractions in PDF
6. next.config.ts is configured for server-side PDF generation
</success_criteria>

<output>
After completion, create `.planning/phases/05-export/05-02-SUMMARY.md`
</output>

---
phase: 05-export
plan: 03
type: execute
wave: 2
depends_on: ["05-02"]
files_modified:
  - lib/queue.ts
  - scripts/export-worker.ts
  - app/api/exams/[examId]/export/pdf/route.ts
  - app/api/exams/[examId]/export/status/route.ts
  - app/api/exams/[examId]/export/download/[filename]/route.ts
  - app/dashboard/exams/[examId]/grading/GradingDashboard.tsx
  - components/export/ExportProgressModal.tsx
autonomous: true

must_haves:
  truths:
    - "Teacher can generate PDF report from grading dashboard"
    - "Large exports (200+ submissions) complete without timeout"
    - "Progress indicator shows export status"
    - "Teacher can filter PDF export by class/subgroup"
    - "Math expressions render in PDF"
  artifacts:
    - path: "lib/queue.ts"
      provides: "Export queue alongside AI grading queue"
      exports: ["exportQueue"]
    - path: "scripts/export-worker.ts"
      provides: "BullMQ worker for PDF generation"
    - path: "app/api/exams/[examId]/export/pdf/route.ts"
      provides: "POST endpoint to start PDF export job"
      exports: ["POST"]
    - path: "app/api/exams/[examId]/export/status/route.ts"
      provides: "GET endpoint for SSE progress streaming"
      exports: ["GET"]
    - path: "components/export/ExportProgressModal.tsx"
      provides: "Progress modal for export status"
      exports: ["ExportProgressModal"]
  key_links:
    - from: "app/api/exams/[examId]/export/pdf/route.ts"
      to: "lib/queue.ts"
      via: "exportQueue.add"
      pattern: "exportQueue\\.add"
    - from: "scripts/export-worker.ts"
      to: "lib/export/pdf-generator.tsx"
      via: "import ExportDocument"
      pattern: "ExportDocument"
    - from: "GradingDashboard.tsx"
      to: "/api/exams/[examId]/export/pdf"
      via: "fetch POST"
      pattern: "export/pdf"
---

<objective>
Implement async PDF export with progress tracking.

Purpose: PDF generation for 200+ submissions would timeout in a synchronous request. Using BullMQ (already integrated for AI grading), we queue export jobs and stream progress to the client.

Output: Working PDF export with async job processing, SSE progress updates, and downloadable files.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-export/05-RESEARCH.md
@.planning/phases/05-export/05-02-SUMMARY.md (after Plan 02 completes)

Key patterns from existing code:
- BullMQ queue pattern in lib/queue.ts
- AI grading worker pattern in scripts/ai-grading-worker.ts
- Grading progress polling in api/exams/[examId]/grading-progress/route.ts
- Session auth in api-auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export Queue and Worker</name>
  <files>lib/queue.ts, scripts/export-worker.ts</files>
  <action>
Extend BullMQ infrastructure for export jobs:

1. Update `lib/queue.ts` to add export queue:

After the existing aiGradingQueue definition, add:
```typescript
/**
 * Export Queue
 *
 * Used to queue PDF/CSV export jobs for large datasets.
 * Jobs include: { examId, classIds?, type: 'pdf' | 'csv' }
 */
export const exportQueue = connection
    ? new Queue('export', {
        connection,
        defaultJobOptions: {
            attempts: 2,
            backoff: {
                type: 'fixed',
                delay: 5000
            },
            removeOnComplete: {
                age: 3600, // Keep completed jobs for 1 hour
                count: 50
            },
            removeOnFail: {
                age: 24 * 3600, // Keep failed jobs for 24 hours
                count: 100
            }
        }
    })
    : null

if (!exportQueue) {
    console.warn('[Queue] Export queue not initialized due to Redis connection failure')
}
```

2. Create `scripts/export-worker.ts`:
```typescript
import { Worker, Job } from 'bullmq'
import Redis from 'ioredis'
import { renderToBuffer } from '@react-pdf/renderer'
import { prisma } from '@/lib/prisma'
import { ExportDocument, AttemptExportData, QuestionExportData } from '@/lib/export/pdf-generator'
import { parseContent, segmentsToPlainText } from '@/lib/content'
import fs from 'fs/promises'
import path from 'path'
import React from 'react'

/**
 * Export Worker
 *
 * Consumes jobs from 'export' queue.
 * Generates PDF reports asynchronously.
 */

const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379'
const EXPORT_DIR = process.env.EXPORT_DIR || path.join(process.cwd(), 'tmp', 'exports')

console.log('[Export Worker] Starting worker...')
console.log(`[Export Worker] Connecting to Redis at ${redisUrl}`)
console.log(`[Export Worker] Export directory: ${EXPORT_DIR}`)

const connection = new Redis(redisUrl, {
    maxRetriesPerRequest: null,
    retryStrategy: (times) => {
        const delay = Math.min(times * 50, 2000)
        return delay
    }
})

connection.on('error', (error) => {
    console.error('[Export Worker] Redis connection error:', error.message)
})

connection.on('connect', () => {
    console.log('[Export Worker] Redis connected successfully')
})

// Ensure export directory exists
async function ensureExportDir() {
    try {
        await fs.mkdir(EXPORT_DIR, { recursive: true })
    } catch (error) {
        console.error('[Export Worker] Failed to create export directory:', error)
    }
}

ensureExportDir()

interface ExportJobData {
    examId: string
    classIds?: string[]
    type: 'pdf'
    requestedBy: string  // User ID for access control
}

const worker = new Worker('export', async (job: Job<ExportJobData>) => {
    const { examId, classIds, type, requestedBy } = job.data
    console.log(`[Export Worker] Processing ${type} export for exam ${examId}`)

    if (type === 'pdf') {
        // 1. Fetch exam data
        await job.updateProgress({ phase: 'loading', current: 0, total: 100 })

        const exam = await prisma.exam.findUnique({
            where: { id: examId },
            include: {
                sections: {
                    include: {
                        questions: {
                            include: {
                                segments: { select: { maxPoints: true } }
                            },
                            orderBy: { order: 'asc' }
                        }
                    },
                    orderBy: { order: 'asc' }
                }
            }
        })

        if (!exam) {
            throw new Error('Exam not found')
        }

        // 2. Build where clause with optional class filter
        const whereClause: any = {
            examId,
            status: { in: ['GRADED', 'SUBMITTED'] }
        }

        if (classIds && classIds.length > 0) {
            const allClassIds = await getClassIdsWithChildren(classIds)
            whereClause.student = {
                enrollments: {
                    some: { classId: { in: allClassIds } }
                }
            }
        }

        // 3. Fetch attempts
        const attempts = await prisma.attempt.findMany({
            where: whereClause,
            include: {
                student: { select: { name: true, email: true } },
                answers: {
                    include: {
                        grades: { select: { score: true, feedback: true } },
                        question: {
                            include: {
                                section: { select: { order: true } },
                                segments: { select: { maxPoints: true } }
                            }
                        },
                        segments: { select: { content: true } }
                    }
                }
            },
            orderBy: { student: { name: 'asc' } }
        })

        await job.updateProgress({ phase: 'processing', current: 10, total: 100 })

        // 4. Build question order map
        const questions = exam.sections.flatMap((s, sIdx) =>
            s.questions.map(q => ({
                id: q.id,
                order: q.order,
                sectionOrder: sIdx + 1,
                content: q.content,
                maxPoints: q.segments.reduce((sum, seg) => sum + (seg.maxPoints ?? 0), 0)
            }))
        )

        // 5. Transform attempts to export data
        const totalAttempts = attempts.length
        const exportAttempts: AttemptExportData[] = []

        for (let i = 0; i < attempts.length; i++) {
            const attempt = attempts[i]

            // Calculate progress (10-80% for processing)
            const progressPct = 10 + Math.round((i / totalAttempts) * 70)
            await job.updateProgress({ phase: 'processing', current: progressPct, total: 100, processed: i + 1, totalAttempts })

            // Build question data
            const questionData: QuestionExportData[] = questions.map(q => {
                const answer = attempt.answers.find(a => a.questionId === q.id)
                const answerContent = answer?.segments.map(s => s.content).join('\n') || ''
                const grade = answer?.grades[0]

                return {
                    id: q.id,
                    order: q.order,
                    sectionOrder: q.sectionOrder,
                    content: q.content,
                    maxPoints: q.maxPoints,
                    studentAnswer: answerContent,
                    score: grade?.score ?? null,
                    feedback: grade?.feedback ?? null
                }
            })

            // Calculate total score
            const totalScore = questionData.reduce((sum, q) => sum + (q.score ?? 0), 0)
            const maxPoints = questions.reduce((sum, q) => sum + q.maxPoints, 0)

            exportAttempts.push({
                id: attempt.id,
                student: {
                    name: attempt.student.name || 'Etudiant',
                    email: attempt.student.email || ''
                },
                submittedAt: attempt.submittedAt?.toISOString() ?? null,
                totalScore,
                maxPoints,
                questions: questionData
            })
        }

        await job.updateProgress({ phase: 'generating', current: 80, total: 100 })

        // 6. Generate PDF
        console.log(`[Export Worker] Generating PDF for ${exportAttempts.length} attempts...`)

        const pdfBuffer = await renderToBuffer(
            React.createElement(ExportDocument, {
                exam: { title: exam.title, description: exam.description },
                attempts: exportAttempts,
                generatedAt: new Date().toISOString()
            })
        )

        await job.updateProgress({ phase: 'saving', current: 95, total: 100 })

        // 7. Save to file
        const filename = `rapport-${exam.title.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}.pdf`
        const filepath = path.join(EXPORT_DIR, filename)

        await fs.writeFile(filepath, pdfBuffer)

        console.log(`[Export Worker] PDF saved to ${filepath} (${pdfBuffer.length} bytes)`)

        await job.updateProgress({ phase: 'complete', current: 100, total: 100 })

        return {
            filename,
            filepath,
            size: pdfBuffer.length,
            attemptCount: exportAttempts.length
        }
    }

    throw new Error(`Unknown export type: ${type}`)
}, {
    connection,
    concurrency: 2  // Max 2 concurrent exports
})

worker.on('completed', (job, result) => {
    console.log(`[Export Worker] Job ${job.id} completed:`, result)
})

worker.on('failed', (job, err) => {
    console.error(`[Export Worker] Job ${job?.id} failed:`, err.message)
})

// Helper function
async function getClassIdsWithChildren(classIds: string[]): Promise<string[]> {
    const classes = await prisma.class.findMany({
        where: {
            OR: [
                { id: { in: classIds } },
                { parentId: { in: classIds } }
            ]
        },
        select: { id: true }
    })
    return classes.map(c => c.id)
}

// Graceful shutdown
const shutdown = async () => {
    console.log('[Export Worker] Shutting down...')
    await worker.close()
    await connection.quit()
    console.log('[Export Worker] Shutdown complete')
    process.exit(0)
}

process.on('SIGTERM', shutdown)
process.on('SIGINT', shutdown)
```

3. Add npm script to package.json:
```json
"worker:export": "tsx scripts/export-worker.ts"
```
  </action>
  <verify>
1. `npx tsc --noEmit lib/queue.ts` - no errors
2. `npx tsc --noEmit scripts/export-worker.ts` - no errors
3. Worker starts without crash: `npm run worker:export` (Ctrl+C to stop)
  </verify>
  <done>Export queue and worker exist, worker starts without errors</done>
</task>

<task type="auto">
  <name>Task 2: PDF Export API Endpoints</name>
  <files>app/api/exams/[examId]/export/pdf/route.ts, app/api/exams/[examId]/export/status/route.ts, app/api/exams/[examId]/export/download/[filename]/route.ts</files>
  <action>
Create API endpoints for PDF export:

1. Create `app/api/exams/[examId]/export/pdf/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getAuthSession, isTeacher } from '@/lib/api-auth'
import { prisma } from '@/lib/prisma'
import { exportQueue } from '@/lib/queue'
import { verifyCsrf, getCsrfCookieName, getAllowedOrigins } from '@/lib/csrf'

// POST /api/exams/[examId]/export/pdf - Start PDF export job
export async function POST(
    req: NextRequest,
    { params }: { params: Promise<{ examId: string }> }
) {
    try {
        const { examId } = await params
        const session = await getAuthSession(req)

        // Auth check
        if (!session || !session.user || !isTeacher(session)) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
        }

        // CSRF check
        const csrfResult = verifyCsrf({
            req,
            cookieToken: req.cookies.get(getCsrfCookieName())?.value,
            headerToken: req.headers.get('x-csrf-token'),
            allowedOrigins: getAllowedOrigins()
        })
        if (!csrfResult.ok) {
            return NextResponse.json({ error: 'CSRF' }, { status: 403 })
        }

        // Verify access to exam
        const exam = await prisma.exam.findUnique({
            where: { id: examId },
            include: {
                course: { select: { institutionId: true } }
            }
        })

        if (!exam) {
            return NextResponse.json({ error: 'Exam not found' }, { status: 404 })
        }

        if (exam.course.institutionId !== session.user.institutionId) {
            return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
        }

        // Check queue availability
        if (!exportQueue) {
            return NextResponse.json({ error: 'Export service unavailable' }, { status: 503 })
        }

        // Parse optional class filter
        const body = await req.json().catch(() => ({}))
        const classIds = body.classIds as string[] | undefined

        // Queue export job
        const job = await exportQueue.add('pdf-export', {
            examId,
            classIds,
            type: 'pdf',
            requestedBy: session.user.id
        })

        return NextResponse.json({
            jobId: job.id,
            status: 'queued'
        })

    } catch (error) {
        console.error('[API] PDF Export Error:', error)
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
    }
}
```

2. Create `app/api/exams/[examId]/export/status/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getAuthSession, isTeacher } from '@/lib/api-auth'
import { exportQueue } from '@/lib/queue'

// GET /api/exams/[examId]/export/status?jobId=xxx - Get export job status
export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ examId: string }> }
) {
    try {
        const { examId } = await params
        const session = await getAuthSession(req)

        if (!session || !session.user || !isTeacher(session)) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
        }

        const jobId = req.nextUrl.searchParams.get('jobId')
        if (!jobId) {
            return NextResponse.json({ error: 'jobId required' }, { status: 400 })
        }

        if (!exportQueue) {
            return NextResponse.json({ error: 'Export service unavailable' }, { status: 503 })
        }

        const job = await exportQueue.getJob(jobId)
        if (!job) {
            return NextResponse.json({ error: 'Job not found' }, { status: 404 })
        }

        // Verify job belongs to this exam
        if (job.data.examId !== examId) {
            return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
        }

        const state = await job.getState()
        const progress = job.progress as { phase?: string; current?: number; total?: number } | undefined

        if (state === 'completed') {
            const result = job.returnvalue as { filename: string; size: number; attemptCount: number }
            return NextResponse.json({
                status: 'completed',
                progress: 100,
                result: {
                    filename: result.filename,
                    size: result.size,
                    attemptCount: result.attemptCount,
                    downloadUrl: `/api/exams/${examId}/export/download/${result.filename}`
                }
            })
        }

        if (state === 'failed') {
            return NextResponse.json({
                status: 'failed',
                error: job.failedReason || 'Unknown error'
            })
        }

        return NextResponse.json({
            status: state,
            progress: progress?.current ?? 0,
            phase: progress?.phase ?? 'queued'
        })

    } catch (error) {
        console.error('[API] Export Status Error:', error)
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
    }
}
```

3. Create `app/api/exams/[examId]/export/download/[filename]/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getAuthSession, isTeacher } from '@/lib/api-auth'
import { prisma } from '@/lib/prisma'
import fs from 'fs/promises'
import path from 'path'

const EXPORT_DIR = process.env.EXPORT_DIR || path.join(process.cwd(), 'tmp', 'exports')

// GET /api/exams/[examId]/export/download/[filename] - Download exported file
export async function GET(
    req: NextRequest,
    { params }: { params: Promise<{ examId: string; filename: string }> }
) {
    try {
        const { examId, filename } = await params
        const session = await getAuthSession(req)

        if (!session || !session.user || !isTeacher(session)) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
        }

        // Verify access to exam
        const exam = await prisma.exam.findUnique({
            where: { id: examId },
            include: {
                course: { select: { institutionId: true } }
            }
        })

        if (!exam) {
            return NextResponse.json({ error: 'Exam not found' }, { status: 404 })
        }

        if (exam.course.institutionId !== session.user.institutionId) {
            return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
        }

        // Sanitize filename to prevent directory traversal
        const sanitizedFilename = path.basename(filename)
        const filepath = path.join(EXPORT_DIR, sanitizedFilename)

        // Verify file exists
        try {
            await fs.access(filepath)
        } catch {
            return NextResponse.json({ error: 'File not found' }, { status: 404 })
        }

        // Read and return file
        const fileBuffer = await fs.readFile(filepath)

        return new Response(fileBuffer, {
            headers: {
                'Content-Type': 'application/pdf',
                'Content-Disposition': `attachment; filename="${sanitizedFilename}"`
            }
        })

    } catch (error) {
        console.error('[API] Export Download Error:', error)
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
    }
}
```
  </action>
  <verify>
TypeScript compilation for all three files:
```bash
npx tsc --noEmit app/api/exams/\[examId\]/export/pdf/route.ts
npx tsc --noEmit app/api/exams/\[examId\]/export/status/route.ts
npx tsc --noEmit app/api/exams/\[examId\]/export/download/\[filename\]/route.ts
```
  </verify>
  <done>Three API endpoints created: POST pdf, GET status, GET download</done>
</task>

<task type="auto">
  <name>Task 3: Export Progress Modal and UI Integration</name>
  <files>components/export/ExportProgressModal.tsx, app/dashboard/exams/[examId]/grading/GradingDashboard.tsx</files>
  <action>
Create progress modal and wire up PDF export button:

1. Create `components/export/ExportProgressModal.tsx`:
```typescript
'use client'

import { useState, useEffect } from 'react'
import { X, Download, Loader2, CheckCircle, XCircle } from 'lucide-react'

interface ExportProgressModalProps {
    examId: string
    jobId: string
    onClose: () => void
}

type ExportStatus = 'queued' | 'active' | 'completed' | 'failed'

interface StatusResponse {
    status: ExportStatus
    progress?: number
    phase?: string
    result?: {
        filename: string
        size: number
        attemptCount: number
        downloadUrl: string
    }
    error?: string
}

export function ExportProgressModal({ examId, jobId, onClose }: ExportProgressModalProps) {
    const [status, setStatus] = useState<StatusResponse>({ status: 'queued', progress: 0 })
    const [polling, setPolling] = useState(true)

    useEffect(() => {
        if (!polling) return

        const pollStatus = async () => {
            try {
                const res = await fetch(`/api/exams/${examId}/export/status?jobId=${jobId}`)
                if (res.ok) {
                    const data: StatusResponse = await res.json()
                    setStatus(data)

                    if (data.status === 'completed' || data.status === 'failed') {
                        setPolling(false)
                    }
                }
            } catch (error) {
                console.error('Error polling export status:', error)
            }
        }

        pollStatus()
        const interval = setInterval(pollStatus, 1000)

        return () => clearInterval(interval)
    }, [examId, jobId, polling])

    const getPhaseLabel = (phase?: string) => {
        switch (phase) {
            case 'loading': return 'Chargement des donnees...'
            case 'processing': return 'Traitement des copies...'
            case 'generating': return 'Generation du PDF...'
            case 'saving': return 'Enregistrement...'
            case 'complete': return 'Termine !'
            default: return 'En attente...'
        }
    }

    const handleDownload = () => {
        if (status.result?.downloadUrl) {
            window.location.href = status.result.downloadUrl
        }
    }

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center">
            <div
                className="absolute inset-0 bg-black/50 backdrop-blur-sm"
                onClick={status.status === 'completed' || status.status === 'failed' ? onClose : undefined}
            />
            <div className="relative bg-white rounded-lg shadow-xl w-full max-w-md mx-4 p-6">
                {/* Close button only when done */}
                {(status.status === 'completed' || status.status === 'failed') && (
                    <button
                        onClick={onClose}
                        className="absolute top-4 right-4 text-gray-400 hover:text-gray-600"
                    >
                        <X className="w-5 h-5" />
                    </button>
                )}

                <div className="text-center">
                    {/* Icon */}
                    <div className="mb-4">
                        {status.status === 'completed' ? (
                            <CheckCircle className="w-12 h-12 mx-auto text-green-500" />
                        ) : status.status === 'failed' ? (
                            <XCircle className="w-12 h-12 mx-auto text-red-500" />
                        ) : (
                            <Loader2 className="w-12 h-12 mx-auto text-indigo-600 animate-spin" />
                        )}
                    </div>

                    {/* Title */}
                    <h3 className="text-lg font-semibold text-gray-900 mb-2">
                        {status.status === 'completed'
                            ? 'Export termine'
                            : status.status === 'failed'
                                ? 'Erreur d\'export'
                                : 'Export en cours...'}
                    </h3>

                    {/* Phase label */}
                    <p className="text-sm text-gray-600 mb-4">
                        {status.status === 'failed'
                            ? status.error || 'Une erreur est survenue'
                            : getPhaseLabel(status.phase)}
                    </p>

                    {/* Progress bar */}
                    {status.status !== 'completed' && status.status !== 'failed' && (
                        <div className="mb-4">
                            <div className="w-full bg-gray-200 rounded-full h-2.5">
                                <div
                                    className="bg-indigo-600 h-2.5 rounded-full transition-all duration-300"
                                    style={{ width: `${status.progress || 0}%` }}
                                />
                            </div>
                            <p className="text-xs text-gray-500 mt-1">{status.progress || 0}%</p>
                        </div>
                    )}

                    {/* Result info */}
                    {status.status === 'completed' && status.result && (
                        <div className="mb-4 text-sm text-gray-600">
                            <p>{status.result.attemptCount} copies exportees</p>
                            <p>Taille: {(status.result.size / 1024).toFixed(1)} Ko</p>
                        </div>
                    )}

                    {/* Actions */}
                    <div className="flex justify-center gap-3 mt-6">
                        {status.status === 'completed' && (
                            <button
                                onClick={handleDownload}
                                className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center gap-2"
                            >
                                <Download className="w-4 h-4" />
                                Telecharger
                            </button>
                        )}
                        {(status.status === 'completed' || status.status === 'failed') && (
                            <button
                                onClick={onClose}
                                className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200"
                            >
                                Fermer
                            </button>
                        )}
                    </div>
                </div>
            </div>
        </div>
    )
}
```

2. Update `GradingDashboard.tsx` to enable PDF export:

Add import at top:
```typescript
import { ExportProgressModal } from '@/components/export/ExportProgressModal'
import { getCsrfToken } from '@/lib/csrfClient'
```

Add state for export modal (after other state declarations):
```typescript
const [exportJobId, setExportJobId] = useState<string | null>(null)
const [isStartingExport, setIsStartingExport] = useState(false)
```

Add export handler function (after handleReleaseResults):
```typescript
const handlePdfExport = async () => {
    setIsStartingExport(true)
    setShowActionsDropdown(false)

    try {
        const csrfToken = await getCsrfToken()
        const res = await fetch(`/api/exams/${examId}/export/pdf`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-csrf-token': csrfToken
            },
            body: JSON.stringify({})  // Could add classIds filter here
        })

        if (res.ok) {
            const data = await res.json()
            setExportJobId(data.jobId)
        } else {
            console.error('Failed to start export')
            alert('Erreur lors du demarrage de l\'export')
        }
    } catch (error) {
        console.error('Export error:', error)
        alert('Erreur lors du demarrage de l\'export')
    } finally {
        setIsStartingExport(false)
    }
}
```

Replace the disabled "Telecharger rapport" button (around line 273-280) with:
```tsx
<button
    onClick={handlePdfExport}
    disabled={isStartingExport}
    className="w-full px-4 py-2 text-left text-gray-700 flex items-center gap-2 hover:bg-gray-50 disabled:text-gray-400"
>
    <FileText className="w-4 h-4" />
    {isStartingExport ? 'Demarrage...' : 'Telecharger rapport (PDF)'}
</button>
```

Add modal at the end of the component (before the closing div):
```tsx
{exportJobId && (
    <ExportProgressModal
        examId={examId}
        jobId={exportJobId}
        onClose={() => setExportJobId(null)}
    />
)}
```
  </action>
  <verify>
1. `npx tsc --noEmit components/export/ExportProgressModal.tsx`
2. `npx tsc --noEmit app/dashboard/exams/[examId]/grading/GradingDashboard.tsx`
3. Manual test: Click "Telecharger rapport (PDF)" shows progress modal
  </verify>
  <done>PDF export button triggers modal, progress polling works, download link appears on completion</done>
</task>

</tasks>

<verification>
1. Export worker starts: `npm run worker:export`
2. All API endpoints compile without errors
3. Click "Telecharger rapport (PDF)" shows progress modal
4. Progress bar updates as export processes
5. "Telecharger" button appears on completion
6. PDF downloads and opens correctly
</verification>

<success_criteria>
1. Teacher can click "Telecharger rapport (PDF)" in grading dashboard
2. Progress modal shows real-time progress (0-100%)
3. Export of 50+ submissions completes without timeout
4. Download button appears when complete
5. PDF contains all student reports with scores and feedback
</success_criteria>

<output>
After completion, create `.planning/phases/05-export/05-03-SUMMARY.md`
</output>

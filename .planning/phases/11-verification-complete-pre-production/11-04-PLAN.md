---
phase: 11-verification-complete-pre-production
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/**/route.ts
  - lib/actions/*.ts
  - lib/csrf.ts
  - lib/securityHeaders.ts
autonomous: true

must_haves:
  truths:
    - "Every POST/PUT/DELETE API route verifies CSRF token before processing"
    - "Every API route checks authentication and role-based authorization"
    - "No raw SQL queries exist — all database access goes through Prisma ORM"
    - "Math/text input rendering is XSS-safe (no dangerouslySetInnerHTML with user content)"
    - "Server actions validate auth and permissions before mutating data"
  artifacts:
    - path: "lib/csrf.ts"
      provides: "CSRF token generation and verification"
      contains: "verifyCsrf"
    - path: "lib/securityHeaders.ts"
      provides: "Security headers configuration"
      contains: "getSecurityHeaders"
  key_links:
    - from: "app/api/**/route.ts"
      to: "lib/csrf.ts"
      via: "verifyCsrf call in POST/PUT/DELETE handlers"
      pattern: "verifyCsrf"
    - from: "app/api/**/route.ts"
      to: "lib/api-auth.ts"
      via: "getServerSession or getAuthSession"
      pattern: "getServerSession|getAuthSession"
---

<objective>
Audit all API routes, server actions, and client-side rendering for security vulnerabilities aligned with OWASP Top 10 — then fix every issue found.

Purpose: Ensure zero critical security vulnerabilities before production deployment.
Output: All API routes protected with auth + CSRF + authorization. No XSS vectors. No raw SQL. All server actions validated.
</objective>

<execution_context>
@C:\Users\hugol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hugol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/csrf.ts
@lib/csrfClient.ts
@lib/fetchJsonWithCsrf.ts
@lib/api-auth.ts
@lib/securityHeaders.ts
@lib/attemptPermissions.ts
@tests/csrf.test.ts
@tests/security-headers.test.ts
@tests/attempt-permissions.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit CSRF protection on all mutation API routes</name>
  <files>app/api/**/route.ts</files>
  <action>
Enumerate ALL API route files in `app/api/`. For each route file, check every exported function (GET, POST, PUT, DELETE, PATCH).

For POST, PUT, DELETE, PATCH handlers:
1. Verify the handler calls `verifyCsrf()` or equivalent CSRF check BEFORE any business logic
2. Verify the CSRF check result is acted upon (returns 403 if failed)
3. Verify the handler checks authentication (getServerSession/getAuthSession) BEFORE CSRF

For GET handlers:
- GET routes should NOT require CSRF (safe methods)
- But GET routes that return sensitive data SHOULD check authentication

Create a checklist tracking each route:
```
Route: app/api/exams/[examId]/route.ts
- GET: auth check [YES/NO], CSRF [N/A]
- PUT: auth check [YES/NO], CSRF [YES/NO], role check [YES/NO]
- DELETE: auth check [YES/NO], CSRF [YES/NO], role check [YES/NO]
```

For any route missing CSRF on mutations:
- Add `verifyCsrf()` call following the established pattern from `app/api/exams/[examId]/route.ts`
- Import required functions: `verifyCsrf`, `getCsrfCookieToken` from `@/lib/csrf`, `getAllowedOrigins` from the appropriate module

For any route missing authentication on mutations:
- Add `getServerSession()` check at the top of the handler

Also audit `lib/actions/*.ts` (server actions):
- `lib/actions/exam-taking.ts`
- `lib/actions/organization.ts`
- `lib/actions/exam-editor.ts`
- Each server action MUST check authentication and role authorization at the start
- Server actions do NOT need CSRF (Next.js handles this for form submissions), but they MUST check `getServerSession()`
  </action>
  <verify>
Grep all POST/PUT/DELETE/PATCH handlers in `app/api/` for `verifyCsrf` to confirm coverage. Count should match total mutation handlers. Grep server actions for `getServerSession` or `getAuthSession`. Run `npx tsc --noEmit`.
  </verify>
  <done>Every POST/PUT/DELETE/PATCH API route calls verifyCsrf(). Every mutation handler checks authentication. Every server action validates auth. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Audit XSS vectors, raw SQL, and authorization gaps</name>
  <files>app/api/**/route.ts, components/**/*.tsx, lib/prisma.ts</files>
  <action>
**XSS Audit:**
1. Search all `.tsx` files for `dangerouslySetInnerHTML` — each instance must be verified safe:
   - If rendering user-provided content: MUST sanitize with DOMPurify or equivalent
   - If rendering static/trusted content: Document why it's safe
2. Search for `innerHTML` assignments in any `.ts`/`.tsx` file
3. Check MathRenderer and KaTeX rendering: Verify that user-provided LaTeX is rendered through KaTeX (which is XSS-safe by design) and NOT through raw HTML insertion
4. Check MathLive input: Verify user input is sanitized before storage

**SQL Injection Audit:**
1. Search for `$queryRaw`, `$executeRaw`, `$queryRawUnsafe`, `$executeRawUnsafe` in all `.ts` files
2. If any raw SQL is found: Verify parameterized queries are used (no string concatenation)
3. Confirm all database access goes through Prisma ORM with its built-in parameterization

**Authorization Audit:**
1. For each role-protected page in `app/student/`, `app/teacher/`, `app/admin/`:
   - Verify the page checks the user's role before rendering
   - Verify the page redirects unauthorized users (not just showing "Access denied" text)
2. For API routes:
   - Verify institution-scoped queries (resource.institutionId === session.user.institutionId)
   - Verify role checks match the expected access pattern:
     - Student routes: Only STUDENT role
     - Teacher routes: TEACHER, SCHOOL_ADMIN, PLATFORM_ADMIN
     - School admin routes: SCHOOL_ADMIN, PLATFORM_ADMIN
     - Platform admin routes: PLATFORM_ADMIN only
3. Check for horizontal privilege escalation: Can a teacher access another teacher's courses? Can a student access another student's attempts? Verify all queries filter by userId or institutionId.

**Input Validation Audit:**
1. Search for API routes that parse `req.json()` — verify they validate the parsed body (Zod schema or manual checks)
2. Check for routes accepting user IDs in params — verify they validate format (UUID/CUID) before querying

For each issue found, fix it:
- XSS: Add sanitization or switch to safe rendering
- Raw SQL: Replace with Prisma query or add parameterization
- Authorization: Add missing role/institution checks
- Validation: Add Zod schema or manual validation
  </action>
  <verify>
Grep for `dangerouslySetInnerHTML` — each instance documented as safe or fixed. Grep for `queryRaw` — zero results or all parameterized. Grep for role checks in page components. Run `npx tsc --noEmit`. Run existing security tests: `npx tsx --test tests/csrf.test.ts tests/security-headers.test.ts tests/attempt-permissions.test.ts`.
  </verify>
  <done>Zero unmitigated XSS vectors. Zero raw SQL. All pages check role authorization. All API routes validate input. Existing security tests pass.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Existing security tests pass: `npx tsx --test tests/*.test.ts`
3. Every mutation API route has CSRF verification (grep confirms)
4. Every server action checks authentication (grep confirms)
5. No `dangerouslySetInnerHTML` with unsanitized user content
6. No raw SQL queries outside of Prisma's safe API
</verification>

<success_criteria>
- 100% of POST/PUT/DELETE/PATCH API routes verify CSRF tokens
- 100% of mutation handlers check authentication
- 100% of server actions validate auth and permissions
- Zero unmitigated XSS vectors in rendering pipeline
- Zero raw SQL queries (all through Prisma ORM)
- All role-protected pages enforce correct role checks
- All existing security tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-verification-complete-pre-production/11-04-SUMMARY.md`
</output>

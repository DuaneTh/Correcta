generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- IAM & Tenancy ---

model Institution {
  id          String   @id @default(uuid())
  name        String
  domain      String?  @unique // For email mapping
  ssoConfig   Json?    // { type: "OIDC" | "SAML", issuer: "...", clientId: "..." }
  settings    Json?    // { branding: {...}, defaultAntiCheat: {...} }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users       User[]
  courses     Course[]
  lmsConfigs  LMSConfig[]
}

enum UserRole {
  PLATFORM_ADMIN
  SCHOOL_ADMIN
  TEACHER
  STUDENT
  EXTERNAL_PROCTOR
}

model User {
  id            String      @id @default(uuid())
  email         String      @unique
  emailVerified DateTime?
  image         String?
  name          String?
  passwordHash  String?     // Nullable if SSO only
  role          UserRole    @default(STUDENT)
  institutionId String?
  institution   Institution? @relation(fields: [institutionId], references: [id])
  
  accounts      Account[]
  sessions      Session[]
  
  enrollments   Enrollment[]
  attempts      Attempt[]
  gradingTasks  GradingTask[] // If human grader
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Account {
  id                 String  @id @default(uuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  refresh_expires_in Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model LMSConfig {
  id            String      @id @default(uuid())
  institutionId String
  institution   Institution @relation(fields: [institutionId], references: [id])
  lmsType       String      // "MOODLE", "CANVAS", etc.
  apiUrl        String?
  ltiKey        String?     // For LTI 1.3
  createdAt     DateTime    @default(now())
}

// --- Academic Structure ---

model Course {
  id            String      @id @default(uuid())
  code          String
  name          String
  institutionId String
  institution   Institution @relation(fields: [institutionId], references: [id])
  
  classes       Class[]
  exams         Exam[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Class {
  id        String       @id @default(uuid())
  name      String       // e.g. "Group A", "TD 1"
  courseId  String
  course    Course       @relation(fields: [courseId], references: [id])
  
  enrollments Enrollment[]
}

model Enrollment {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  classId   String
  class     Class    @relation(fields: [classId], references: [id])
  role      UserRole // STUDENT or TEACHER for this specific class
  
  @@unique([userId, classId])
}

// --- Exam & Content ---

model Exam {
  id              String   @id @default(uuid())
  title           String
  description     String?  // Description détaillée de l'examen
  courseId        String
  course          Course   @relation(fields: [courseId], references: [id])
  classIds        String[] // IDs des classes ciblées
  
  startAt         DateTime
  endAt           DateTime? // Optional if duration based window
  durationMinutes Int

  authorId        String?   // ID of the user who created the exam
  
  antiCheatConfig Json?    // { webcam: boolean, screen: boolean, ... }
  gradingConfig   Json?    // { releaseGradesAt: DateTime, ... }
  
  sections        ExamSection[] // Renommé de questionGroups
  attempts        Attempt[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model ExamSection {
  id        String     @id @default(uuid())
  examId    String
  exam      Exam       @relation(fields: [examId], references: [id])
  title     String     // "Part 1"
  order     Int        @default(0)
  
  questions Question[]
}

enum QuestionType {
  TEXT
  MCQ
  CODE
}

model Question {
  id              String   @id @default(uuid())
  sectionId       String
  section         ExamSection @relation(fields: [sectionId], references: [id])
  content         String   // Markdown/HTML
  type            QuestionType
  order           Int      @default(0)
  
  segments        QuestionSegment[]
  answers         Answer[]
}

model QuestionSegment {
  id          String   @id @default(uuid())
  questionId  String
  question    Question @relation(fields: [questionId], references: [id])
  
  instruction String   // Specific instruction for this segment
  maxPoints   Float
  
  rubric      Rubric?
  answerSegments AnswerSegment[]
}

model Rubric {
  id          String   @id @default(uuid())
  segmentId   String   @unique
  segment     QuestionSegment @relation(fields: [segmentId], references: [id])
  
  criteria    String?  // General guidance
  levels      Json     // [{ points: 5, description: "Perfect" }, { points: 0, ... }]
  examples    Json?    // [{ content: "...", type: "GOOD" }]
}

// --- Execution & Grading ---

enum AttemptStatus {
  IN_PROGRESS
  SUBMITTED
  GRADING_IN_PROGRESS
  GRADED
}

model Attempt {
  id            String        @id @default(uuid())
  examId        String
  exam          Exam          @relation(fields: [examId], references: [id])
  studentId     String
  student       User          @relation(fields: [studentId], references: [id])
  
  startedAt     DateTime      @default(now())
  submittedAt   DateTime?
  status        AttemptStatus @default(IN_PROGRESS)
  
  antiCheatScore Float?       // 0.0 to 1.0 suspicion score
  
  answers       Answer[]
  proctorEvents ProctorEvent[]
  gradingTasks  GradingTask[]
}

model Answer {
  id          String   @id @default(uuid())
  attemptId   String
  attempt     Attempt  @relation(fields: [attemptId], references: [id])
  questionId  String
  question    Question @relation(fields: [questionId], references: [id])
  
  segments    AnswerSegment[]
  grades      Grade[]      // Question-level grades
  
  @@unique([attemptId, questionId])
}

model AnswerSegment {
  id          String   @id @default(uuid())
  answerId    String
  answer      Answer   @relation(fields: [answerId], references: [id])
  segmentId   String
  segment     QuestionSegment @relation(fields: [segmentId], references: [id])
  
  content     String   // Student response
  autosavedAt DateTime? // Dernière sauvegarde automatique
  
  grade       Grade?
  
  @@unique([answerId, segmentId])
}

model Grade {
  id              String         @id @default(uuid())
  
  // For question-level grades (manual grading)
  answerId        String?        @unique
  answer          Answer?        @relation(fields: [answerId], references: [id])
  
  // For segment-level grades (future AI grading)
  answerSegmentId String?        @unique
  answerSegment   AnswerSegment? @relation(fields: [answerSegmentId], references: [id])
  
  score           Float
  feedback        String?        // Teacher comment or AI feedback
  aiRationale     String?        // AI-specific rationale
  isOverridden    Boolean        @default(false)
  gradedByUserId  String?        // Null if AI, userId if manual
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
}

// --- Anti-Cheat & Logs ---

enum ProctorEventType {
  FOCUS_LOST
  FOCUS_GAINED
  TAB_SWITCH
  FULLSCREEN_EXIT
  INACTIVITY         // Inactivité prolongée (soft anti-cheat)
  MULTI_SESSION      // Détection session multiple (soft anti-cheat)
  MULTIPLE_FACES
  ABSENCE
  NOISE_DETECTED
  COPY               // Clipboard copy event
  PASTE              // Clipboard paste event
}

model ProctorEvent {
  id        String           @id @default(uuid())
  attemptId String
  attempt   Attempt          @relation(fields: [attemptId], references: [id])
  
  type      ProctorEventType
  timestamp DateTime         @default(now())
  metadata  Json?            // { duration: 5s, confidence: 0.9 }
}

// --- Async Tasks ---

enum TaskStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model GradingTask {
  id          String     @id @default(uuid())
  attemptId   String
  attempt     Attempt    @relation(fields: [attemptId], references: [id])
  
  status      TaskStatus @default(PENDING)
  assignedTo  String?    // User ID if manual review
  user        User?      @relation(fields: [assignedTo], references: [id])
  
  error       String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
}
